<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Graph</title>
      <link href="/2020/01/19/Graph/"/>
      <url>/2020/01/19/Graph/</url>
      
        <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图</p><p>一个一维数组存储图中的顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息</p><h3 id="结构及创建"><a href="#结构及创建" class="headerlink" title="结构及创建"></a>结构及创建</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VMAXN 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535  <span class="comment">//界定值</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>  //图</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> vers[VMAXN];  <span class="comment">//顶点表</span></span><br><span class="line"><span class="keyword">int</span> arc[VMAXN][VMAXN];  <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> Vers_num;  <span class="comment">//顶点数</span></span><br><span class="line"><span class="keyword">int</span> Edge_num;  <span class="comment">//边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MGraph_Create</span><span class="params">(struct Graph* graph)</span>  <span class="comment">//创建</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">scanf_s(<span class="string">"%d %d"</span>, &amp;graph-&gt;Vers_num, &amp;graph-&gt;Edege_num);  <span class="comment">//输入顶点数和边数</span></span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;Vers_num; i++)</span><br><span class="line">scanf_s(<span class="string">"%s"</span>, &amp;graph-&gt;vers[i], <span class="keyword">sizeof</span>(<span class="keyword">char</span>));  <span class="comment">//输入顶点信息，建立顶点表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;Vers_num; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph-&gt;Vers_num; j++)</span><br><span class="line">graph-&gt;arc[i][j] = INFINITY;  <span class="comment">//邻接矩阵初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;Edge_num; i++)  <span class="comment">//读入边数，建立邻接矩阵</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;  <span class="comment">//u，v，w 分别代表边（ku，kv）上的下标 u，下标 v 和权 w</span></span><br><span class="line">scanf_s(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">graph-&gt;arc[u][v] = w;</span><br><span class="line">graph-&gt;arc[v][u] = graph-&gt;arc[u][v];  <span class="comment">//无向图，所以矩阵对称</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>用数组和链表组合储存，称为邻接表（Adjacency List）</p><p>顶点用一维数组储存，也可以用单链表，但是数组更好读取顶点信息，顶点数组中每个元素还存储指向第一个邻接点的指针，所有邻接点构成一个线性表，由于邻接点个数不定，所以用单链表存储，无向图称为顶点 vi 的边表，有向图则称为顶点 vi 作为弧尾的出边表</p><p>对于有向图，可以再构建一个逆邻接表，即对每个顶点 vi 都建立一个链接为 vi 为弧头的表</p><p>对于带权值的网图，再加一个 weight 的数据域即可</p><h3 id="结构及创建-1"><a href="#结构及创建-1" class="headerlink" title="结构及创建"></a>结构及创建</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VMAXN 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>  //边表结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> under_bid;  <span class="comment">//邻接点域，该顶点对应的下标</span></span><br><span class="line"><span class="keyword">int</span> weight;  <span class="comment">//权</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>* <span class="title">next</span>;</span>  <span class="comment">//链域，指向下一个邻接点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>  //顶点表结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> data;  <span class="comment">//顶点域，顶点信息存储</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>* <span class="title">firstEdge</span>;</span>  <span class="comment">//边表头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GraphAdjList</span>  //邻接表</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> <span class="title">adjlist</span>[<span class="title">VMAXN</span>];</span>  <span class="comment">//顶点存储</span></span><br><span class="line"><span class="keyword">int</span> Vers_num;  <span class="comment">//当前顶点数</span></span><br><span class="line"><span class="keyword">int</span> Edge_num;  <span class="comment">//当前边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LGraph_Create</span><span class="params">(struct GraphAdjList* graph)</span>  <span class="comment">//创建一个无向图的邻接表（无权，非网图）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">scanf_s(<span class="string">"%d %d"</span>, &amp;graph-&gt;Vers_num, &amp;graph-&gt;Edge_num);  <span class="comment">//顶点数和边数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;Vers_num; i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf_s(<span class="string">"%s"</span>, graph-&gt;adjlist[i].data, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));  <span class="comment">//输入每个顶点信息</span></span><br><span class="line">graph-&gt;adjlist[i].firstEdge = <span class="literal">NULL</span>;  <span class="comment">//边表为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;Edge_num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;  <span class="comment">//边（nu，nv）上的顶点序号</span></span><br><span class="line">scanf_s(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>* <span class="title">e</span> = (<span class="title">struct</span> <span class="title">Edge</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Edge</span>));</span>  <span class="comment">//动态内存，生成边表结点</span></span><br><span class="line">e-&gt;under_bid = v;  <span class="comment">//临界序号为 v</span></span><br><span class="line">e-&gt;next = graph-&gt;adjlist[u].firstEdge;  <span class="comment">//e 指向当前顶点指向的结点</span></span><br><span class="line">graph-&gt;adjlist[u].firstEdge = e;  <span class="comment">//当前顶点指针指向 e</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>* <span class="title">f</span> = (<span class="title">struct</span> <span class="title">Edge</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Edge</span>));</span>  <span class="comment">//动态内存，生成边表结点</span></span><br><span class="line">f-&gt;under_bid = u;  <span class="comment">//临界序号为 u</span></span><br><span class="line">f-&gt;next = graph-&gt;adjlist[v].firstEdge;  <span class="comment">//f 指向当前顶点指向的结点</span></span><br><span class="line">graph-&gt;adjlist[v].firstEdge = f;  <span class="comment">//当前顶点指针指向 f</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="/2020/01/12/String/"/>
      <url>/2020/01/12/String/</url>
      
        <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary tree</title>
      <link href="/2020/01/09/Binary-tree/"/>
      <url>/2020/01/09/Binary-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>这玩意儿很离谱，暂时还不晓得具体可以用在些什么地方</p><p>主要是……学的东西就尼玛只有遍历啥的，虚得很……先整完这些吧</p><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_tree</span>  //二叉树</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;  <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_tree</span>* <span class="title">child_left</span>;</span>  <span class="comment">//左子节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_tree</span>* <span class="title">child_right</span>;</span>  <span class="comment">//右子节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct binary_tree* <span class="title">Create_Tree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_tree</span>* <span class="title">Tree_top</span> = (<span class="title">struct</span> <span class="title">binary_tree</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">binary_tree</span>));</span>  <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line"><span class="keyword">int</span> tree_data;  <span class="comment">//新数据</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;tree_data);</span><br><span class="line"><span class="keyword">if</span> (tree_data != <span class="number">0</span>)  <span class="comment">//这里的限制条件是如果数据是 0，就不存在这个结点</span></span><br><span class="line">&#123;</span><br><span class="line">Tree_top-&gt;data = tree_data;</span><br><span class="line">Tree_top-&gt;child_left = Create_Tree();  <span class="comment">//以左子节点为左树的树顶</span></span><br><span class="line">Tree_top-&gt;child_right = Create_Tree();  <span class="comment">//以右子节点为右树的树顶</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> Tree_top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历算法是从树顶然后分向左树至右树一一输出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Binary_tree_Print</span><span class="params">(struct binary_tree* tree_top)</span>  <span class="comment">//前序遍历算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree_top == <span class="literal">NULL</span>)  <span class="comment">//当前树为空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, tree_top-&gt;data);  <span class="comment">//输出当前树的值</span></span><br><span class="line">Binary_tree_Print(tree_top-&gt;child_left);  <span class="comment">//输出左树</span></span><br><span class="line">Binary_tree_Print(tree_top-&gt;child_right);  <span class="comment">//输出右树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历是从左树返回树顶然后到右树输出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Binary_tree_Print_In</span><span class="params">(struct binary_tree* tree_top)</span>  <span class="comment">//中序遍历算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree_top == <span class="literal">NULL</span>)  <span class="comment">//当前树为空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">Binary_tree_Print_In(tree_top-&gt;child_left);  <span class="comment">//输出左树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, tree_top-&gt;data);  <span class="comment">//输出当前树的值</span></span><br><span class="line">Binary_tree_Print_In(tree_top-&gt;child_right);  <span class="comment">//输出右树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历算法是从左到右先叶后顶输出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Binary_tree_Print_Post</span><span class="params">(struct binary_tree* tree_top)</span>  <span class="comment">//后序遍历算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree_top == <span class="literal">NULL</span>)  <span class="comment">//当前树为空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">Binary_tree_Print_Post(tree_top-&gt;child_left);  <span class="comment">//输出左树</span></span><br><span class="line">Binary_tree_Print_Post(tree_top-&gt;child_right);  <span class="comment">//输出右树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, tree_top-&gt;data);  <span class="comment">//输出当前树的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>从根节点开始，从左至右一层一层往下遍历，略过……</p><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>只是多了两个叶节点判断标志而已</p><h3 id="结构定义及建立"><a href="#结构定义及建立" class="headerlink" title="结构定义及建立"></a>结构定义及建立</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Point_tag  <span class="comment">//叶节点状态,Link值为 0 代表指向左右子节点,Thread值为 1 代表指向前驱或者后继的线索</span></span><br><span class="line">&#123;</span><br><span class="line">Link, Thread</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treaded_binary_tree</span>  //线索二叉树</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;  <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treaded_binary_tree</span>* <span class="title">child_left</span>;</span>  <span class="comment">//左子节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treaded_binary_tree</span>* <span class="title">child_right</span>;</span>  <span class="comment">//右子节点</span></span><br><span class="line"><span class="keyword">bool</span> tag_left;  <span class="comment">//左标志</span></span><br><span class="line"><span class="keyword">bool</span> tag_right;  <span class="comment">//右标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct treaded_binary_tree* <span class="title">Create_Binary_Tree</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treaded_binary_tree</span>* <span class="title">Tree_top</span> = (<span class="title">struct</span> <span class="title">treaded_binary_tree</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">treaded_binary_tree</span>));</span>  <span class="comment">//动态二维空间</span></span><br><span class="line"><span class="keyword">int</span> tree_data;  <span class="comment">//数据</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;tree_data);</span><br><span class="line"><span class="keyword">if</span> (tree_data != <span class="number">0</span>)  <span class="comment">//不为 0 时</span></span><br><span class="line">&#123;</span><br><span class="line">Tree_top-&gt;data = tree_data;</span><br><span class="line">Tree_top-&gt;child_left = Create_Binary_Tree();</span><br><span class="line"><span class="keyword">if</span> (Tree_top-&gt;child_left != <span class="literal">NULL</span>)  <span class="comment">//左标志标记</span></span><br><span class="line">Tree_top-&gt;tag_left = Link;</span><br><span class="line">Tree_top-&gt;child_right = Create_Binary_Tree();</span><br><span class="line"><span class="keyword">if</span> (Tree_top-&gt;child_right != <span class="literal">NULL</span>)  <span class="comment">//右标志标记</span></span><br><span class="line">Tree_top-&gt;tag_right = Link;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> Tree_top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="中序遍历线索化"><a href="#中序遍历线索化" class="headerlink" title="中序遍历线索化"></a>中序遍历线索化</h3><p>线索化之前需要定义一个指向根结点（即树顶）的头结点Head，就像双向链表的结构一样</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treaded_binary_tree</span>* <span class="title">t</span>;</span>  <span class="comment">//全局变量，指向刚才访问过的结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Binary_tree_Threaded_In</span><span class="params">(struct treaded_binary_tree* Tree_top)</span>  <span class="comment">//无头结点的中序线索化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree_top != <span class="literal">NULL</span>)  <span class="comment">//不为空</span></span><br><span class="line">&#123;</span><br><span class="line">Binary_tree_Threaded_In(Tree_top-&gt;child_left);  <span class="comment">//左树</span></span><br><span class="line"><span class="keyword">if</span> (Tree_top-&gt;child_left == <span class="literal">NULL</span>)  <span class="comment">//无左树</span></span><br><span class="line">&#123;</span><br><span class="line">Tree_top-&gt;tag_left = Thread;  <span class="comment">//前驱线索</span></span><br><span class="line">Tree_top-&gt;child_left = t;  <span class="comment">//左指针指向前驱</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;child_right == <span class="literal">NULL</span>)  <span class="comment">//前驱无右树</span></span><br><span class="line">&#123;</span><br><span class="line">t-&gt;tag_right = Thread;  <span class="comment">//后继线索</span></span><br><span class="line">t-&gt;child_right = Tree_top;  <span class="comment">//前驱右指针指向后继</span></span><br><span class="line">&#125;</span><br><span class="line">t = Tree_top;  <span class="comment">//保持 t 指向Tree_top的前驱</span></span><br><span class="line">Binary_tree_Threaded_In(Tree_top-&gt;child_right);  <span class="comment">//右树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct treaded_binary_tree* <span class="title">Head_Treading</span><span class="params">(struct treaded_binary_tree* Binary_tree_treaded)</span>  <span class="comment">//中序线索化主体，返还头结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treaded_binary_tree</span>* <span class="title">Head</span> = (<span class="title">struct</span> <span class="title">treaded_binary_tree</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">treaded_binary_tree</span>));</span>  <span class="comment">//动态内存</span></span><br><span class="line">t = Binary_tree_treaded;  <span class="comment">//t一开始指向根结点</span></span><br><span class="line">Binary_tree_Threaded_In(Binary_tree_treaded);  <span class="comment">//无头结点的中序线索化，在后面加入头结点进行调整</span></span><br><span class="line">Head-&gt;child_left = Binary_tree_treaded;  <span class="comment">//头结点左指针指向根结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treaded_binary_tree</span>* <span class="title">q</span> = <span class="title">Binary_tree_treaded</span>;</span>  <span class="comment">//分配 q 来作为第一个结点（第一个结点就是中序遍历中第一个整的结点）</span></span><br><span class="line"><span class="keyword">while</span> (q-&gt;tag_left == Link)</span><br><span class="line">q = q-&gt;child_left;</span><br><span class="line">q-&gt;child_left = Head;  <span class="comment">//第一个结点的左指针指向头结点（一开始是指向根结点）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treaded_binary_tree</span>* <span class="title">p</span> = <span class="title">Binary_tree_treaded</span>;</span>  <span class="comment">//分配 p 来作为最后一刻个结点（最后一个结点就是中序遍历中最后一个整的结点）</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;tag_right == Link)</span><br><span class="line">p = p-&gt;child_right;</span><br><span class="line">Head-&gt;child_right = p;  <span class="comment">//最后一个结点的右指针指向头结点（一开始哪里也没指）</span></span><br><span class="line">p-&gt;child_right = Head;  <span class="comment">//头结点的右指针指向最后一个结点（一开始哪里也没指）</span></span><br><span class="line">Head-&gt;tag_left = Link;  <span class="comment">//头结点的左指针指向的是根结点</span></span><br><span class="line">Head-&gt;tag_right = Thread;  <span class="comment">//头结点的右指针是前驱后继</span></span><br><span class="line"><span class="keyword">return</span> Head;</span><br></pre></td></tr></table></figure></div><h3 id="线索二叉树的遍历输出"><a href="#线索二叉树的遍历输出" class="headerlink" title="线索二叉树的遍历输出"></a>线索二叉树的遍历输出</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Binary_tree_Threaded_Print</span><span class="params">(struct treaded_binary_tree* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treaded_binary_tree</span>* <span class="title">p</span> = <span class="title">head</span>-&gt;<span class="title">child_left</span>;</span>  <span class="comment">//p指向根结点</span></span><br><span class="line"><span class="keyword">while</span> (p != head)  <span class="comment">//空树或者遍历结束时，p == head</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;tag_left == Link)  <span class="comment">//循环到中序序列的第一个结点</span></span><br><span class="line">p = p-&gt;child_left;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);  <span class="comment">//输出</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;tag_right == Thread &amp;&amp; p-&gt;child_right != head)  <span class="comment">//前驱右指针指向后继时，并且后继不为头结点时</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;child_right;  <span class="comment">//前往右指针指向后继</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);  <span class="comment">//输出</span></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;child_right;  <span class="comment">//p前往右树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="树、二叉树与森林"><a href="#树、二叉树与森林" class="headerlink" title="树、二叉树与森林"></a>树、二叉树与森林</h1><h2 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h2><ol><li>加线：在所有兄弟节点之间加一条连线</li><li>去线：对树中每一个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线</li><li>层次调整：大致意思为将树的样子变得好看一些，层次更加鲜明一些，注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子</li></ol><h2 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h2><ol><li>把每棵树转换为二叉树</li><li>第一棵二叉树不动，从第二颗起，依次把后一棵二叉树的根节点作为前一棵二叉树的根节点的右孩子</li></ol><h2 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h2><ol><li>加线：若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、左孩子的右孩子的右孩子结点…….</li></ol><p>左孩子的n个右孩子结点都作为此结点的孩子，用线连接</p><ol start="2"><li>去线：删除原二叉树中所有结点与其右孩子结点的连线</li><li>层次调整：略过……</li></ol><h2 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h2><p>判断一棵二叉树能否转换为森林还是树，只需要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树</p><ol><li>从根节点开始，若右孩子存在，则把与右孩子结点的连线删除，再看分离后的二叉树，再进行操作，直到所有的与根节点相关的右孩子连线都被删除</li><li>再将每棵分离后的二叉树转换为树即可</li></ol><h2 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><h4 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h4><p>先访问根结点，然后依次遍历根的每颗子树</p><h4 id="后根遍历"><a href="#后根遍历" class="headerlink" title="后根遍历"></a>后根遍历</h4><p>先依次访问每颗子树，然后访问根结点</p><h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><h4 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>先访问第一棵树的根结点，然后依次先根遍历，然后遍历剩下的森林</p><h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>先访问第一棵树，用后根遍历，然后遍历剩下的森林</p><p>我们不难发现，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同</p><h1 id="二叉树应用"><a href="#二叉树应用" class="headerlink" title="二叉树应用"></a>二叉树应用</h1><h2 id="赫曼夫树"><a href="#赫曼夫树" class="headerlink" title="赫曼夫树"></a>赫曼夫树</h2><p>带权路径长度WPL最小的二叉树称之为赫曼夫树</p><h3 id="构造算法"><a href="#构造算法" class="headerlink" title="构造算法"></a>构造算法</h3><ol><li>根据给定的n个权值{w1,w2······wn}构成n棵二叉树的集合F={T1,T2······Tn}，其中每棵二叉树Ti中只有一个带权为wi的根结点，其左右子树均为空</li><li>在F中选取两棵根结点权值最小的树作为左右子树构造一棵新的二叉树，且置信的二叉树的根结点的权值为其左右子树上根节点的权值之和</li><li>在F中删除这两棵树，同时将新得到的二叉树加入F中</li><li>重复2、3直到F中只有一棵树为止，这棵树就是赫曼夫树</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quick Select</title>
      <link href="/2020/01/09/Quick-Select/"/>
      <url>/2020/01/09/Quick-Select/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Quick Sort</title>
      <link href="/2020/01/09/Quick-Sort/"/>
      <url>/2020/01/09/Quick-Sort/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是啥，是一个很顶的排序，二话不多说，上代码以示友好</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基值在一个区块中，左边的数要小，右边的数要大*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>];  <span class="comment">//定义长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Quick_patition</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;  <span class="comment">//申明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span>  <span class="comment">//交换数组中下标为u、v的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = a[u];</span><br><span class="line">a[u] = a[v];</span><br><span class="line">a[v] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>  <span class="comment">//对当前区块（从left到right这一段）进行操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (right - left &lt;= <span class="number">0</span>)  <span class="comment">//如果该区块的长度已经小于等于 0，结束对这个区块的操作</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> pivot = Quick_patition(left, right);  <span class="comment">//得到这个区块的基值所在的位置</span></span><br><span class="line">Quick_Sort(left, pivot - <span class="number">1</span>);  <span class="comment">//对这一个区块中分出来的左区块进行操作</span></span><br><span class="line">Quick_Sort(pivot + <span class="number">1</span>, right);  <span class="comment">//对这一个区块分出来的有区块进行操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Quick_patition</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>  <span class="comment">//left是左标在数组的小标，right是右标在数组的下标（这个函数用以得到基值在当前区块的位置）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> base = right--;  <span class="comment">//定义区块的基值为最右边的数，base为基值所在的下标</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)  <span class="comment">//只有左标移动到了右标的位置处才会结束循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (a[left] &lt; a[base])  <span class="comment">//先移动左标，比较左标与基值，如果左标小于基值，左标右移，直到左标大于等于基值</span></span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">while</span> (a[right] &gt; a[base])  <span class="comment">//再移动右标，比较右标与基值，如果右标大于基值，右标左移，直到右标小于等于基值</span></span><br><span class="line">right--;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)  <span class="comment">//如果左标已经移动到了右标处甚至右标的右边，则结束</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//如果左标还没有移动到右标的位置，就交换左标与右标</span></span><br><span class="line">swap(left, right);</span><br><span class="line">&#125;</span><br><span class="line">swap(left, base);  <span class="comment">//交换左标与基值，使基值位于该区块中间</span></span><br><span class="line"><span class="keyword">return</span> left;  <span class="comment">//返还左标的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">//数组中值个数</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//赋值</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">Quick_Sort(<span class="number">0</span>, n - <span class="number">1</span>);  <span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hash table</title>
      <link href="/2020/01/09/Hash-table/"/>
      <url>/2020/01/09/Hash-table/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Queue</title>
      <link href="/2020/01/09/Queue/"/>
      <url>/2020/01/09/Queue/</url>
      
        <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列和栈刚好相反嗷，它是先进先出的线性表（FIFO）</p><p>允许删除的一端称为队头（front），允许插入的一端称为对尾（rear）</p><h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><p>由于数组存储空间的问题（即假溢出），我们使用的队列应该是头尾相接的循环队列，不然很容易就会超出数组范围</p><p>顺带一提队列长度计算公式：( rear - front + QueueSize ) % QueueSize</p><h3 id="结构定义及初始化"><a href="#结构定义及初始化" class="headerlink" title="结构定义及初始化"></a>结构定义及初始化</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Status int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>  //循环队列的顺序结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data[maxn];  <span class="comment">//队列中元素</span></span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Queue_Init</span><span class="params">(struct Queue* <span class="built_in">queue</span>)</span>  <span class="comment">//队列初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>-&gt;front = <span class="number">0</span>;  <span class="comment">//队头归零</span></span><br><span class="line"><span class="built_in">queue</span>-&gt;rear = <span class="number">0</span>;  <span class="comment">//队尾归零</span></span><br><span class="line"><span class="keyword">return</span> RIGHT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">SqQueue</span>;</span></span><br><span class="line"><span class="keyword">if</span> (Queue_Init(&amp;SqQueue) != RIGHT)  <span class="comment">//队列创建</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Queue_Enter</span><span class="params">(struct Queue* <span class="built_in">queue</span>, <span class="keyword">int</span> elem)</span>  <span class="comment">//入队，elem为入队元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % maxn == <span class="built_in">queue</span>-&gt;front)  <span class="comment">//队列满</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;rear] = elem;  <span class="comment">//队尾插入元素</span></span><br><span class="line"><span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % maxn;  <span class="comment">//队尾延伸，如果到了尽头，就转到数组最前面</span></span><br><span class="line"><span class="keyword">return</span> RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Queue_Delete</span><span class="params">(struct Queue* <span class="built_in">queue</span>, <span class="keyword">int</span>* elem)</span>  <span class="comment">//出队，elem储存出队元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear)  <span class="comment">//队列空</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*elem = <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;front];  <span class="comment">//elem储存出队的元素</span></span><br><span class="line"><span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % maxn;  <span class="comment">//队头后移，如果到了尽头，就转到数组最前面</span></span><br><span class="line"><span class="keyword">return</span> RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="队列长度"><a href="#队列长度" class="headerlink" title="队列长度"></a>队列长度</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Queue_Length</span><span class="params">(struct Queue <span class="built_in">queue</span>)</span>  <span class="comment">//队列长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">queue</span>.rear - <span class="built_in">queue</span>.front + maxn) % maxn;  <span class="comment">//公式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h2><p>队头指针指向头结点，队尾指针指向终端结点</p><h3 id="链式队列的结构及建立"><a href="#链式队列的结构及建立" class="headerlink" title="链式队列的结构及建立"></a>链式队列的结构及建立</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>  //链式队列的结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;  <span class="comment">//数值域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span>  //链式队列</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">front</span>;</span>  <span class="comment">//队头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">rear</span>;</span>  <span class="comment">//队尾指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span> <span class="title">Queue_link</span>;</span>  <span class="comment">//建立链式队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">head</span>;</span>  <span class="comment">//定义头节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//头结点指向空</span></span><br><span class="line">Queue_link.front = head;  <span class="comment">//队头指针指向头结点</span></span><br><span class="line">Queue_link.rear = head;  <span class="comment">//队尾指针指向头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkQueue_Enter</span><span class="params">(struct LinkQueue* <span class="built_in">queue</span>, <span class="keyword">int</span> elem)</span>  <span class="comment">//入队，elem为入队元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">q</span>;</span>  <span class="comment">//q作为新的终端结点</span></span><br><span class="line">q = (struct QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct QueueNode));  <span class="comment">//为q分配内存空间</span></span><br><span class="line"><span class="keyword">if</span> (!q)  <span class="comment">//分配失败</span></span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);  <span class="comment">//在math.h头文件中，其值为 3，用以终止程序并上报系统缓存上溢</span></span><br><span class="line">q-&gt;data = elem;  <span class="comment">//终端结点赋值</span></span><br><span class="line">q-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//终端结点指向空</span></span><br><span class="line"><span class="built_in">queue</span>-&gt;rear-&gt;next = q;  <span class="comment">//原队尾指针指向终端结点</span></span><br><span class="line"><span class="built_in">queue</span>-&gt;rear = q;  <span class="comment">//将终端节点赋给队尾指针</span></span><br><span class="line"><span class="keyword">return</span> RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkQueue_Delete</span><span class="params">(struct LinkQueue* <span class="built_in">queue</span>, <span class="keyword">int</span>* elem)</span>  <span class="comment">//出队，elem储存出队元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">p</span>;</span>  <span class="comment">//p临时储存出队元素</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear)  <span class="comment">//空队列</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">p = <span class="built_in">queue</span>-&gt;front-&gt;next;  <span class="comment">//出队的是头结点的下一个结点</span></span><br><span class="line">*elem = p-&gt;data;  <span class="comment">//储存</span></span><br><span class="line"><span class="built_in">queue</span>-&gt;front-&gt;next = p-&gt;next;  <span class="comment">//头结点指向原来队首元素所指向 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;rear == p)  <span class="comment">//如果出队的是最后一个元素，在出队后队尾指针指向队头指针</span></span><br><span class="line"><span class="built_in">queue</span>-&gt;rear = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line"><span class="built_in">free</span>(p);  <span class="comment">//释放内存</span></span><br><span class="line"><span class="keyword">return</span> RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack</title>
      <link href="/2020/01/09/Stack/"/>
      <url>/2020/01/09/Stack/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>何谓栈者，就是数据存储进去，先入的反而后出的一种线性表（LIFO）</p><p>允许插入和删除的一端称为栈顶（top），另一端称之为栈底（bottom），不含任何数据元素的栈称为空栈</p><h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><h3 id="结构定义及建栈"><a href="#结构定义及建栈" class="headerlink" title="结构定义及建栈"></a>结构定义及建栈</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Status int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>  //栈的顺序存储结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data[maxn];  <span class="comment">//栈中储存元素</span></span><br><span class="line"><span class="keyword">int</span> top;  <span class="comment">//栈顶</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> <span class="title">Sqstack</span>;</span>  <span class="comment">//建栈</span></span><br><span class="line">Sqstack.top = <span class="number">-1</span>;  <span class="comment">//一开始为空栈，栈顶位置为 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="压栈"><a href="#压栈" class="headerlink" title="压栈"></a>压栈</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Stack_Push</span><span class="params">(struct Stack* <span class="built_in">stack</span>, <span class="keyword">int</span> elem)</span>  <span class="comment">//压栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == maxn - <span class="number">1</span>)  <span class="comment">//栈满</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = elem;  <span class="comment">//栈顶上移，然后将elem赋给栈顶</span></span><br><span class="line"><span class="keyword">return</span> RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="弹栈"><a href="#弹栈" class="headerlink" title="弹栈"></a>弹栈</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Stack_Pop</span><span class="params">(struct Stack* <span class="built_in">stack</span>, <span class="keyword">int</span>* elem)</span>  <span class="comment">//弹出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>)  <span class="comment">//空栈</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*elem = <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top--];  <span class="comment">//栈顶元素赋给elem，然后栈顶下降</span></span><br><span class="line"><span class="keyword">return</span> RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="双栈共享空间"><a href="#双栈共享空间" class="headerlink" title="双栈共享空间"></a>双栈共享空间</h3><p>事实上，这种数据结构（双栈）的使用，一般是两个栈的空间需求相反时，是一个小技巧嗷</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoubleStack</span>  //双栈共享空间结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data[maxn];  <span class="comment">//栈中储存元素</span></span><br><span class="line"><span class="keyword">int</span> top1;  <span class="comment">//栈1栈顶</span></span><br><span class="line"><span class="keyword">int</span> top2;  <span class="comment">//栈2栈顶</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h4 id="压栈-1"><a href="#压栈-1" class="headerlink" title="压栈"></a>压栈</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DoubleStack_Push</span><span class="params">(struct DoubleStack* double_stack, <span class="keyword">int</span> elem, <span class="keyword">int</span> stack_number)</span>  <span class="comment">//压栈，elem为压入元素，stack_number为栈号参数，用以判断压入的是哪一个栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (double_stack-&gt;top1 + <span class="number">1</span> == double_stack-&gt;top2)  <span class="comment">//栈满</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span> (stack_number == <span class="number">1</span>)  <span class="comment">//压入一号栈</span></span><br><span class="line">double_stack-&gt;data[++double_stack-&gt;top1] = elem;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (stack_number == <span class="number">2</span>)  <span class="comment">//压入二号栈</span></span><br><span class="line">double_stack-&gt;data[--double_stack-&gt;top2] = elem;</span><br><span class="line"><span class="keyword">return</span> RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="弹栈-1"><a href="#弹栈-1" class="headerlink" title="弹栈"></a>弹栈</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DoubleStack_Pop</span><span class="params">(struct DoubleStack* double_stack, <span class="keyword">int</span>* elem, <span class="keyword">int</span> stack_number)</span>  <span class="comment">//弹栈。elem储存弹出元素，stack_number为栈号参数，用以判断弹出的是哪一个栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stack_number == <span class="number">1</span>)  <span class="comment">//弹出一号栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (double_stack-&gt;top1 == <span class="number">-1</span>)  <span class="comment">//空栈</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*elem = double_stack-&gt;data[double_stack-&gt;top1--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (stack_number == <span class="number">2</span>)  <span class="comment">//弹出二号栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (double_stack-&gt;top2 == maxn)  <span class="comment">//空栈</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*elem = double_stack-&gt;data[double_stack-&gt;top2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h2><p>链栈不需要头节点嗷，栈顶就是链头，当链栈为空时，其实就是top = NULL的时候</p><h3 id="链栈的结构及建立"><a href="#链栈的结构及建立" class="headerlink" title="链栈的结构及建立"></a>链栈的结构及建立</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>  //链栈结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;  <span class="comment">//数值域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span>  //链栈</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">top</span>;</span>  <span class="comment">//链头</span></span><br><span class="line"><span class="keyword">int</span> count;  <span class="comment">//链中结点数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> <span class="title">Stack_link</span>;</span>  <span class="comment">//建栈</span></span><br><span class="line">Stack_link.top = <span class="literal">NULL</span>;  <span class="comment">//初始化空栈</span></span><br><span class="line">Stack_link.count = <span class="number">0</span>;  <span class="comment">//没有元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkStack_Push</span><span class="params">(struct LinkStack* <span class="built_in">stack</span>, <span class="keyword">int</span> elem)</span>  <span class="comment">//进栈，elem为进栈元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StackNode* s = (struct StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct StackNode));  <span class="comment">//为新结点（新栈顶）分配动态内存空间</span></span><br><span class="line">s-&gt;data = elem;  <span class="comment">//赋值</span></span><br><span class="line">s-&gt;next = <span class="built_in">stack</span>-&gt;top;  <span class="comment">//新栈顶（新结点）指向原栈顶</span></span><br><span class="line"><span class="built_in">stack</span>-&gt;top = s;  <span class="comment">//新结点直接赋给栈顶指针</span></span><br><span class="line"><span class="built_in">stack</span>-&gt;count++;  <span class="comment">//栈中元素 + 1</span></span><br><span class="line"><span class="keyword">return</span> RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkStack_Pop</span><span class="params">(struct LinkStack* <span class="built_in">stack</span>, <span class="keyword">int</span>* elem)</span>  <span class="comment">//出栈，elem储存出栈元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StackNode* p;  <span class="comment">//临时存放出栈元素，回收处理，防止内存泄漏</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="literal">NULL</span>)  <span class="comment">//空栈</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*elem = <span class="built_in">stack</span>-&gt;top-&gt;data;  <span class="comment">//栈顶元素赋给elem</span></span><br><span class="line">p = <span class="built_in">stack</span>-&gt;top;  <span class="comment">//p指向栈顶</span></span><br><span class="line"><span class="built_in">stack</span>-&gt;top = <span class="built_in">stack</span>-&gt;top-&gt;next;  <span class="comment">//栈顶指针指向栈顶元素指向</span></span><br><span class="line"><span class="built_in">free</span>(p);  <span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">stack</span>-&gt;count--;  <span class="comment">//栈中元素 - 1</span></span><br><span class="line"><span class="keyword">return</span> RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked list</title>
      <link href="/2019/12/17/Linked-list/"/>
      <url>/2019/12/17/Linked-list/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>基础概念不需要了，就总结一下链表相关操作吧（网上博客里的大佬们都说链表是很简单的【手动滑稽】）</p><ol><li>建立</li><li>输出</li><li>查找</li><li>修改</li><li>插入</li><li>删除</li><li>倒置</li><li>粉碎</li></ol><h2 id="建立与输出"><a href="#建立与输出" class="headerlink" title="建立与输出"></a>建立与输出</h2><p>要实现其他基本操作，首先先要创建一个链表，并能够将其输出，此处将建立与输出整合到一起</p><h3 id="尾插法创建单链表"><a href="#尾插法创建单链表" class="headerlink" title="尾插法创建单链表"></a><b style="color:blue">尾插法创建单链表</b></h3><p>这样生成的链表为正序</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;  <span class="comment">//数值域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">next</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这里是建立部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">head</span>;</span>  <span class="comment">//指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">p</span>, * <span class="title">q</span>;</span> <span class="comment">//声明指向当前结点的指针（用以创建节点），指向上一结点的指针（用以链接）</span></span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//定义一个整型的n作为这个链表的长度</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">head = (struct S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct S));  <span class="comment">//为头结点申请分配动态内存空间</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//将头结点中的指向下一节点的指针暂时性置为NULL</span></span><br><span class="line">q = head;  <span class="comment">//将头结点的指针赋值给“上一结点”，对于第二个结点来说，它的上一节点就是头结点，这就是这样赋值的意义</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">//循环 n 次</span></span><br><span class="line">&#123;</span><br><span class="line">p = (struct S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct S));  <span class="comment">//为当前结点申请分配动态内存空间（开辟一块新的“当前结点”）</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;p-&gt;data);  <span class="comment">//为数据域赋值</span></span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//将当前结点中的当中的指向下一结点的指针暂时性置为NULL，尽量这么做，因为这样最后一个结点的指针就能舒服地指向NULL</span></span><br><span class="line">q-&gt;next = p;  <span class="comment">//将上一结点的指向下一结点的指针指向当前结点</span></span><br><span class="line">q = p;  <span class="comment">//上一结点的指针指向当前结点为下一结点服务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是输出部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">visit</span>;</span>  <span class="comment">//创建一个指向当前结点的指针</span></span><br><span class="line">visit = head-&gt;next;  <span class="comment">//当前结点指向头结点指向的下一结点</span></span><br><span class="line"><span class="keyword">while</span> (visit != <span class="literal">NULL</span>)  <span class="comment">//如果当前结点的地址不为NULL的话</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visit-&gt;next == <span class="literal">NULL</span>)  <span class="comment">//判断当前结点屁股后面还有没有结点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, visit-&gt;data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, visit-&gt;data);</span><br><span class="line">visit = visit-&gt;next;  <span class="comment">//指向当前结点的指针指向下一结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是头插法</span></span><br></pre></td></tr></table></figure></div><h3 id="头插法创建单链表"><a href="#头插法创建单链表" class="headerlink" title="头插法创建单链表"></a><b style="color:red">头插法创建单链表</b></h3><p>这样生成的链表为逆序（其实和尾插法比起来只有中间有两三行的变动）</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;  <span class="comment">//数值域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">next</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这里是建立部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">head</span>;</span>  <span class="comment">//指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">p</span>, * <span class="title">q</span>;</span> <span class="comment">//声明指向当前结点的指针（用以创建节点），指向上一结点的指针（用以链接）</span></span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//定义一个整型的n作为这个链表的长度</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">head = (struct S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct S));  <span class="comment">//为头结点申请分配动态内存空间</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//将头结点中的指向下一节点的指针暂时性置为NULL</span></span><br><span class="line">q = head;  <span class="comment">//将头结点的指针赋值给“上一结点”，对于第二个结点来说，它的上一节点就是头结点，这就是这样赋值的意义</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">//循环 n 次</span></span><br><span class="line">&#123;</span><br><span class="line">p = (struct S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct S));  <span class="comment">//为当前结点申请分配动态内存空间（开辟一块新的“当前结点”）</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;p-&gt;data);  <span class="comment">//为数据域赋值</span></span><br><span class="line">p-&gt;next = head-&gt;next;  <span class="comment">//新结点的 next 指向头指针所连接的指针</span></span><br><span class="line">head-&gt;next = p;  <span class="comment">//头结点的 next 指针指向新结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是输出部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">visit</span>;</span>  <span class="comment">//创建一个指向当前结点的指针</span></span><br><span class="line">visit = head-&gt;next;  <span class="comment">//当前结点指向头结点指向的下一结点</span></span><br><span class="line"><span class="keyword">while</span> (visit != <span class="literal">NULL</span>)  <span class="comment">//如果当前结点的地址不为NULL的话</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visit-&gt;next == <span class="literal">NULL</span>)  <span class="comment">//判断当前结点屁股后面还有没有结点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, visit-&gt;data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, visit-&gt;data);</span><br><span class="line">visit = visit-&gt;next;  <span class="comment">//指向当前结点的指针指向下一结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是头插法</span></span><br></pre></td></tr></table></figure></div><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>众所周知，链表没有像指针那样的下标，不支持随机访问，所以要查找某接待你，必须通过遍历的方式</p><p>就比如我希望定义一个函数，它可以实现：我输入一个值，它可以返还这个值在链表中的结点的位置，如果找不到就返还 -1</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(struct S* head, <span class="keyword">int</span> r)</span>  <span class="comment">//head 即是头结点，r 是要查找的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">temp</span>;</span>  <span class="comment">//定义用以遍历的指针</span></span><br><span class="line">temp = head;  <span class="comment">//指针首先指向头结点</span></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>; <span class="comment">//结点所在的位置</span></span><br><span class="line"><span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)  <span class="comment">//判断</span></span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;  <span class="comment">//指针后移</span></span><br><span class="line"><span class="keyword">if</span> (r == temp-&gt;data)</span><br><span class="line"><span class="keyword">return</span> t;  <span class="comment">//其实这里返还的只有首位置，但是没大问题</span></span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//显然没有找到，返还 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>如果想要修改某一结点的数值域，首先要遍历找到这个结点，然后直接修改</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Replace</span><span class="params">(struct S* head, <span class="keyword">int</span> u, <span class="keyword">int</span> v)</span>  <span class="comment">//head 即是头结点，u 是节点位置，v 是修改后的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">temp</span>;</span>  <span class="comment">//定义用以遍历的指针</span></span><br><span class="line">temp = head-&gt;next;  <span class="comment">//指针首先指向开始的结点（头节点里无东西）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; u; i++)</span><br><span class="line">temp = temp-&gt;next;  <span class="comment">//指针后移</span></span><br><span class="line">temp-&gt;data = v;  <span class="comment">//直接修改</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>有三种插入的方法：</p><ol><li>头插</li><li>尾插</li><li>插入中间</li></ol><p>但是插入的方法差不多，都是先将新结点的 next 指向插入节点后的那个结点，然后将插入结点前的那个结点的 next 指向插入结点</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(struct S* head, <span class="keyword">int</span> u, <span class="keyword">int</span> v)</span>  <span class="comment">//head 即是头结点，u 是插入的位置，v 是传入的数值域</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">temp</span>;</span>  <span class="comment">//定义用以遍历的指针</span></span><br><span class="line">temp = head;  <span class="comment">//指针首先指向头结点</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((temp != <span class="literal">NULL</span>) &amp;&amp; (i &lt; u - <span class="number">1</span>))  <span class="comment">//首先找到插入结点的上一个结点，即第(u - 1)个结点</span></span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((temp == <span class="literal">NULL</span>) || (i &gt; u - <span class="number">1</span>))  <span class="comment">//错误处理：链表为空或者不存在这个插入的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error!\n"</span>);  <span class="comment">//输出错误信息</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* _<span class="title">new</span> = (<span class="title">struct</span> <span class="title">S</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">S</span>));</span>  <span class="comment">//创建新结点_new</span></span><br><span class="line">_new-&gt;data = v;  <span class="comment">//赋值给插入的新结点的数据域</span></span><br><span class="line">_new-&gt;next = temp-&gt;next;  <span class="comment">//新结点的 next 指针指向插入位置后的结点</span></span><br><span class="line">temp-&gt;next = _new;  <span class="comment">//插入位置前的结点的 next 指针指向新结点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>当删除结点的时候，主要是两步操作：（一定要按顺序！）</p><ol><li>被删除结点的前一个结点的 next 指针指向被删除结点之后的结点（即将被删除结点“孤立出来”）</li><li>释放被删除结点的内存</li></ol><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(struct S* head, <span class="keyword">int</span> u, <span class="keyword">int</span>* v)</span>  <span class="comment">//head 即是头结点，u 是删除的位置，v 用以保存被删除节点的数值域</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">temp</span>;</span>  <span class="comment">//定义用以遍历的指针</span></span><br><span class="line">temp = head;  <span class="comment">//指针首先指向头结点</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((temp != <span class="literal">NULL</span>) &amp;&amp; (i &lt; u - <span class="number">1</span>))  <span class="comment">//就像插入一样，首先找到插入结点的上一个结点，即第(u - 1)个结点</span></span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((temp == <span class="literal">NULL</span>) || (i &gt; u - <span class="number">1</span>))  <span class="comment">//错误处理：链表为空或者不存在这个插入的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error!\n"</span>);  <span class="comment">//输出错误信息（就像插入一样，依然需要错误处理）</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* _<span class="title">del</span> = <span class="title">temp</span>-&gt;<span class="title">next</span>;</span>  <span class="comment">//定义 _del 指向被删除的结点</span></span><br><span class="line">*v = _del-&gt;data;  <span class="comment">//保存被删除结点的数值域</span></span><br><span class="line">temp-&gt;next = _del-&gt;next;  <span class="comment">//被删除结点的上一个结点指向被删除结点的下一个节点</span></span><br><span class="line"><span class="built_in">free</span>(_del);  <span class="comment">//手动释放这个节点，防止内存泄漏</span></span><br><span class="line">_del = <span class="literal">NULL</span>;  <span class="comment">//指向空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="倒置"><a href="#倒置" class="headerlink" title="倒置"></a>倒置</h2><p>倒置算是这几种基本操作里面比较麻烦、难得理解的一个操作了</p><p>首先让头节点与第一个元素节点断开，但是要注意在断开之前需要用p指针指向第一个元素节点来保存第一个元素节点的位置，然后再断开。在这里有一个指针q指向一个指针域为空的节点，这个节点用来做为链表反转后的最后一个节点</p><p>让第二个元素节点的指针从指向第三个元素节点变为指向第一个元素节点，以此类推，直至指针p指向原链表最后一个元素</p><p>p指针指向NULL时，让原头节点的指针域指向原来最后一个元素节点。此时链表倒置已完成。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reserve</span><span class="params">(struct S* head)</span>  <span class="comment">//head 即是头结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">temp</span>;</span>  <span class="comment">//temp 暂时储存 p 所指向结点的下一个结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">p</span>, * <span class="title">q</span>;</span>  <span class="comment">//p 用以遍历除开头结点之外的所有结点，并对它们进行操作</span></span><br><span class="line">p = head-&gt;next;  <span class="comment">//p 指向 head 的下一个结点</span></span><br><span class="line">q = <span class="literal">NULL</span>;  <span class="comment">//q 用以作为未操作完的新链表的临时头结点（除开头结点外的其他结点再进行操作时的头结点的）</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)  <span class="comment">//在 p 完成对尾结点的操作之后结束</span></span><br><span class="line">&#123;</span><br><span class="line">temp = p-&gt;next;  <span class="comment">//用temp 暂时储存 p 所指向结点的下一个结点，防止丢失后面的结点链</span></span><br><span class="line">p-&gt;next = q;  <span class="comment">//p 指向 q</span></span><br><span class="line">q = p;  <span class="comment">//q 指向 p 所指向的结点，即新的头结点</span></span><br><span class="line">p = temp;  <span class="comment">//更新 p，使 p 指向下一个结点</span></span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = q;  <span class="comment">//头结点 head 指向 q</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="粉碎"><a href="#粉碎" class="headerlink" title="粉碎"></a>粉碎</h2><p>粉碎也不能就只把头指针断掉，还要一个一个释放掉内存并清空嗷</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Crush</span><span class="params">(struct S* head)</span>  <span class="comment">//head 即使头结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">temp</span>;</span>  <span class="comment">//temp 暂时储存头结点所指的结点</span></span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">NULL</span>)  <span class="comment">//head 为空的时候结束</span></span><br><span class="line">&#123;</span><br><span class="line">temp = head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(head);  <span class="comment">//释放</span></span><br><span class="line">head = temp;  <span class="comment">//新的头结点（即前一个头结点的下一个结点）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="骚操作"><a href="#骚操作" class="headerlink" title="骚操作"></a>骚操作</h2><h3 id="合并两个有序链表为一个新的有序链表"><a href="#合并两个有序链表为一个新的有序链表" class="headerlink" title="合并两个有序链表为一个新的有序链表"></a>合并两个有序链表为一个新的有序链表</h3><p>今天（2019.12.29）看见的，Leetcode上的大神写的，递归实现，太强了吧</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List_Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List_Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;  <span class="comment">//结构体</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct List_Node* <span class="title">Merge_Lists</span> <span class="params">( struct List_Node* L1, struct List_Node* L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> L2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> L1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>(L1-&gt;val &lt;= L2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            L1-&gt;next = Merge_Lists(L1-&gt;next, L2);</span><br><span class="line">            <span class="keyword">return</span> L1;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">        L2-&gt;next = Merge_Lists(L1, L2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> L2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="双向链表相关"><a href="#双向链表相关" class="headerlink" title="双向链表相关"></a>双向链表相关</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About Struct</title>
      <link href="/2019/12/17/About-Struct/"/>
      <url>/2019/12/17/About-Struct/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>写这个主要是之前第一次用结构体AC了一道题，就巨兴奋，感觉想要记录下来，然后结构体在刷题中的确蛮好玩的，挺香，接下来是我之前刷过的两道题（应该会补充）</p><h2 id="HDU1004"><a href="#HDU1004" class="headerlink" title="HDU1004"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1004" target="_blank" rel="noopener">HDU1004</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有很多组测试，每一组首先给出一个数值，代表接下来出现的颜色个数，如果给出的数值为 0，则结束测试，每一组中，要你输出出现最多的颜色</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>每种不一样的颜色使用一个结构体储存（储存名字和数量），每次输入都对储存不同颜色的结构体数组进行一次遍历，使用strcmp判断是否这个颜色已经“记录在案”，如果没有存在则使用strcpy将其储存下来（记得第一次特判（I think））</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS  <span class="comment">//这个预处理命令加不加没必要，可以忽略一些警告的，比如VS2019中的安全性问题</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">20</span>];  <span class="comment">//a 作为当前颜色而存在</span></span><br><span class="line"><span class="keyword">char</span> b[<span class="number">20</span>];  <span class="comment">//b 储存数量最多的颜色</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> u[<span class="number">20</span>];  <span class="comment">//储存颜色名字</span></span><br><span class="line"><span class="keyword">int</span> v;       <span class="comment">//储存当前该颜色的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//多少组数据</span></span><br><span class="line"><span class="keyword">int</span> t;  </span><br><span class="line"><span class="keyword">int</span> m;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> <span class="title">k</span>[1005];</span>  </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="number">0</span>;  <span class="comment">//记录颜色种类</span></span><br><span class="line">m = <span class="number">0</span>;  <span class="comment">//每种颜色数量的最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//这组共输入 n 个颜色</span></span><br><span class="line">&#123;</span><br><span class="line">scanf_s(<span class="string">"%s"</span>, &amp;a, <span class="keyword">sizeof</span>(a));  <span class="comment">//更为安全的定义字符数组的方式</span></span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">0</span>)  <span class="comment">//此处判断第一个输入的颜色</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(k[<span class="number">0</span>].u, a);  <span class="comment">//把第一个输入的字符录入结构体数组中</span></span><br><span class="line">k[<span class="number">0</span>].v = <span class="number">1</span>;  <span class="comment">//该颜色数量初始化为 1</span></span><br><span class="line">t++;  <span class="comment">//颜色种类 + 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; j++)  <span class="comment">//遍历已有的颜色</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(k[j].u, a) == <span class="number">0</span>)  <span class="comment">//如果这种颜色已经出现过，就只需要增加这种颜色的数量</span></span><br><span class="line">&#123;</span><br><span class="line">k[j].v++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j == t - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(k[t].u, a);  <span class="comment">//如果这种颜色没有出现过，就增加一个颜色种类</span></span><br><span class="line">k[t].v = <span class="number">1</span>;  <span class="comment">//该颜色数量初始化为 1</span></span><br><span class="line">t++;  <span class="comment">//该颜色种类 + 1</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)  <span class="comment">//遍历所有颜色</span></span><br><span class="line"><span class="keyword">if</span> (k[i].v &gt; m)  <span class="comment">//判断最大值</span></span><br><span class="line">&#123;</span><br><span class="line">m = k[i].v;  <span class="comment">//把当前颜色的最大值储存入 m</span></span><br><span class="line"><span class="built_in">strcpy</span>(b, k[i].u);  <span class="comment">//把当前数量最大的颜色储存入 b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, b);  <span class="comment">//输出最大值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="HDU2550"><a href="#HDU2550" class="headerlink" title="HDU2550"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2550" target="_blank" rel="noopener">HDU2550</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>一开始给出一个值，代表接下来的测试组数，每组先输入一个数，代表每组有多少对数据（A,B），每对数据的意思是有箭身长度为 A 的箭 B 枝，（这一道题是新生赛前的热身赛里的一道题，很离谱，热身赛全部题目的题干都巨尼玛中二，一道最简单的求距离的题可以说得玄乎其玄），然后要你按照箭身长度输出每种弓箭，每种弓箭之间还要空行（需要结构体排序）</p><p>就比如A = 3，B = 4的话就要输出这种箭   &gt;+-+&gt;</p><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><p>这一道题的难点其实就只有结构体排序部分，只要结构体排序整出来了就很简单嗷</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>  //定义结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">r</span><span class="params">(struct S x, struct S y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.u &lt; y.u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span>[50];</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s[i].u &gt;&gt; s[i].v;</span><br><span class="line">        sort(s, s + n, r);  <span class="comment">//结构体排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i].v; j++)  <span class="comment">//输出部分（只要排好序了这一部分没得问题）</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&gt;+"</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s[i].u - <span class="number">2</span>; k++)</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"+&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九余</title>
      <link href="/2019/12/16/%E4%B9%9D%E4%BD%99%E5%AE%9A%E7%90%86/"/>
      <url>/2019/12/16/%E4%B9%9D%E4%BD%99%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="九余定理"><a href="#九余定理" class="headerlink" title="九余定理"></a>九余定理</h1><p>九余定理是一个和数学有关的知识，可以了解一下</p><p>首先要介绍<b style="color:red">九余数的概念</b>：一个数的各位数字之和相加后得到的&lt;10的数字称为这个数（如果相加结果大于9，则继续各位相加）</p><p>然后是<b style="color:red">九余定理的定义</b>：一个数 x，他的每个位上的数加起来为 y，九余数为（y - 1）再对 9 求余然后加1，用 C 语言表示就是 ( y - 1 ) % 9 + 1</p><p>emmm，就是说一个数，如果我要求它的九余数，怎么求呢，这样求？</p><h4 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a><b style="color:green">代码一</b></h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s, t;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> ((<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &amp;&amp; (n != <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">s = s + n % <span class="number">10</span>;</span><br><span class="line">n = n / <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s &lt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">n = s;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这是我第一次做的时候的代码，发现在处理较大的数时行不通，所以就换一种，再看看这种？</p><h4 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a><b style="color:green">代码二</b></h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;x)&amp;&amp;(x[<span class="number">0</span>] != <span class="string">'0'</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; x[i]; ++i)</span><br><span class="line">            t = t + x[i] - <span class="string">'0'</span>;</span><br><span class="line">        t = t % <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t)</span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">if</span>(x[<span class="number">0</span>] == <span class="string">'0'</span>)                             <span class="comment">//这里是特判 0 的情况</span></span><br><span class="line">                t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>就诞生了这个代码，没办法，因为处理较大的数的时候只好用字符来存储，但是还是不够简洁，下面就是九余定理</p><h4 id="代码三"><a href="#代码三" class="headerlink" title="代码三"></a><b style="color:green">代码三</b></h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> n[<span class="number">100000</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>((<span class="built_in">scanf</span>(<span class="string">"%s"</span>,n)!=EOF)&amp;&amp;n[<span class="number">0</span>]!=<span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(n); i++)</span><br><span class="line">            s = s + n[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (s - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>My opinion</title>
      <link href="/2019/12/16/My-opinion/"/>
      <url>/2019/12/16/My-opinion/</url>
      
        <content type="html"><![CDATA[<h1 id="对管理系统的一些看法"><a href="#对管理系统的一些看法" class="headerlink" title="对管理系统的一些看法"></a>对管理系统的一些看法</h1><p>整个这个幺蛾子呢，主要是平时学习学累了的时候就可以看看别的组的任务，还挺香的。</p><h2 id="主体方面"><a href="#主体方面" class="headerlink" title="主体方面"></a><b style="color:gold">主体方面</b></h2><p>无论是哪个管理系统，都不可能脱离注册、登录、信息修改、设置管理员是不是，还有美观界面等等其它骚操作，所以我们分成点一个一个地解决，一步一步来</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a><b style="color:red">注册</b></h3><p>注册，首先我们需要在用户<b style="color:cyan">注册成功的同时</b>创建一个<b style="color:red">专属于该用户</b>的文本文档用以储存该用户的所有信息（下面就不采用调用函数的形式了）</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>] = <span class="string">""</span>;  <span class="comment">//用户名</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">word</span>[<span class="number">20</span>] = <span class="string">""</span>;  <span class="comment">//密码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE* fp;  <span class="comment">//这个你学文件里面应该有滴</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">user</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">scanf_s(<span class="string">"%s"</span>, user.name, <span class="keyword">sizeof</span>(user.name));  <span class="comment">//安全性</span></span><br><span class="line">fp = fopen(user.name, <span class="string">"r"</span>);  <span class="comment">//以只读的方式打开这个文件，fp指向以user.name为名的文件，如果没有这个文件，则fp指向NULL</span></span><br><span class="line"><span class="keyword">if</span> (fp != <span class="literal">NULL</span>)  <span class="comment">//说明已经存在这个文件，就不可以用这个用户名注册，进行你想要的操作</span></span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//说明这个用户名可用，其实在前面还可以加上判断用户名长度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//然后是输入密码并确认密码的操作</span></span><br><span class="line">&#125;</span><br><span class="line">fp = fopen(user.name, <span class="string">"w"</span>);  <span class="comment">//user.name写入文件，user.name是文件名，要是没有成功，fp指向NULL</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)  <span class="comment">//显然注册失败</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//注册成功</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//任意发挥，比如输出一些话</span></span><br><span class="line"><span class="keyword">if</span> (fwrite(&amp;user, <span class="keyword">sizeof</span>(User), <span class="number">1</span>, fp) != <span class="number">1</span>)  <span class="comment">/*第一个是指向结构体的地址，第二个是写入内容的大小，</span></span><br><span class="line"><span class="comment">   第三个是数据项的个数（这里我只要写入一个结构体，所以是 1），第四个是目标文件指针</span></span><br><span class="line"><span class="comment">   返还值是实际的写入数据项的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//要是返还值不是 1，就说明写入文件错误，可以输出一个提示，然后退出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到此为止，这就是注册的基本架构啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a><b style="color:red">登录</b></h3><p>要登陆，首先是要<b style="color:red">建立在这个用户创建了的基础上</b>，就是说我要<b style="color:blue">可以找到</b>属于这个用户的文本文档，要是找不到，就说明不存在这个用户，就可以提示并结束，然后找到了用户之后需要比较原始密码与输入密码（可以加入输错三次锁死或退出之类的）</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>] = <span class="string">""</span>;  <span class="comment">//用户名</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">word</span>[<span class="number">20</span>] = <span class="string">""</span>;  <span class="comment">//密码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE* fp;  <span class="comment">//这个你学文件里面应该有滴</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">user</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  <span class="comment">// 好啦，接下来是在有了注册的基础上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> _id[<span class="number">20</span>]; <span class="comment">//用以输入的用户名</span></span><br><span class="line"><span class="keyword">char</span> _pass[<span class="number">20</span>];  <span class="comment">//用以输入的密码</span></span><br><span class="line">scanf_s(<span class="string">"%s"</span>, _id, <span class="keyword">sizeof</span>(_id));</span><br><span class="line">fp = fopen(_id, <span class="string">"r+"</span>);  <span class="comment">//只读，看是不是存在这个用户名</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)  <span class="comment">//显然不存在</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//进行你想要的操作</span></span><br><span class="line">&#125;</span><br><span class="line">fread(&amp;user, <span class="keyword">sizeof</span>(User), <span class="number">1</span>, fp);  <span class="comment">//从fp所指向的文件处读取user的信息</span></span><br><span class="line">scanf_s(<span class="string">"%s"</span>, &amp;_pass, <span class="keyword">sizeof</span>(_pass));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(user.<span class="keyword">word</span>, _pass) != <span class="number">0</span>)  <span class="comment">//比较正确密码与输入的密码</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输错了，咋办</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对啦，登陆成功啦</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>(未完……前面也还需要补充)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 思考与学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编</title>
      <link href="/2019/12/16/%E6%B1%87%E7%BC%96/"/>
      <url>/2019/12/16/%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="PWN——汇编"><a href="#PWN——汇编" class="headerlink" title="PWN——汇编"></a>PWN——汇编</h1><p>最近在了解PWN和WEB，PWN的话先是说搞汇编，就学一下，我寻思掌握了的基础知识也没有丢上来的必要，就记录一下遇到的坎和重难点之类的吧</p><h2 id="1-一些基本概念"><a href="#1-一些基本概念" class="headerlink" title="1. 一些基本概念"></a><b style="color:red">1. 一些基本概念</b></h2><p><strong>a.</strong> 汇编语言与机器语言的区别在于<em>指令的表示方式</em></p><p><strong>b.</strong> 汇编语言由 3 类指令组成：</p><ol><li>汇编指令：机器码的助记符，有对应的机器码</li><li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li><li>其他符号：如 +、-、*、/ 等，由编译器识别，没有对应的机器码</li></ol><p>(未完……….)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 思考与学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2054</title>
      <link href="/2019/12/16/HDU-2054/"/>
      <url>/2019/12/16/HDU-2054/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU2054"><a href="#HDU2054" class="headerlink" title="HDU2054 !"></a><b style="color:cyan">HDU2054 !</b></h1><h2 id="A-B"><a href="#A-B" class="headerlink" title="A==B?"></a><b style="color:blue">A==B?</b></h2><h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2054" target="_blank" rel="noopener">HDU2054</a>这道题，好久之前做的一道挺有意思的水题，这一题从暑假开始一直A到开学后十几天，终于是做出来了，一开始太天真地以为它真的就是道下饭的题（虽然的确挺水），结果自己的操作是真的下饭，很离谱，但是后来还是莫名想通了，去搜了自己要的东西就顺利做了出来。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>虽然是比较两个数是否相等，但是并不是让你比较两个整形，这本质上其实还是道大数题，CSDN、博客园里面有蛮多人的代码都考虑太多，主要有这几种情况：</p><p><strong>·</strong> 要考虑小数点和其后的无效零</p><p><strong>·</strong> 不要考虑前导零</p><p><strong>·</strong> 不要考虑正负号</p><p>所以可以开一个字符数组，分别检索小数点存在与否（可以使用 strstr 或者 for 循环遍历查找），然后将其后的 0 全部转化为 ‘\0’ （终止符），最后将小数点转化为 ‘\0’ （终止符），最后用 strcmp比较即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S</span><span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    l = <span class="built_in">strlen</span>(s);  <span class="comment">//取字符数组的长度</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(s, <span class="string">"."</span>))  <span class="comment">//使用strstr查找是否存在小数点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l - <span class="number">1</span>; s[i] == <span class="string">'0'</span>; i--)  <span class="comment">//从最后一位向前去除所有后置无效零</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = <span class="string">'\0'</span>;</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[l - <span class="number">1</span>] == <span class="string">'.'</span>)  <span class="comment">//去除小数点</span></span><br><span class="line">        s[l - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(scanf_s(<span class="string">"%s %s"</span>, &amp;a, &amp;b, <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(b)) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        S(a);</span><br><span class="line">        S(b);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a, b) == <span class="number">0</span>)  <span class="comment">//比较</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Some Complaing</title>
      <link href="/2019/12/16/Some-Complaing/"/>
      <url>/2019/12/16/Some-Complaing/</url>
      
        <content type="html"><![CDATA[<h1 id="抱怨亿句"><a href="#抱怨亿句" class="headerlink" title="抱怨亿句"></a>抱怨亿句</h1><p>啊啊啊，我搞了几个小时，终于会自己上传文章了，之前要搞那个尺取法，这会儿舒服了我去</p><h2 id="我遇到了的困难"><a href="#我遇到了的困难" class="headerlink" title="我遇到了的困难"></a><b style="color:red">我遇到了的困难</b></h2><h3 id="1-Tags"><a href="#1-Tags" class="headerlink" title="1. Tags"></a>1. Tags</h3><p>首先是GIT找不到上传文件，后来把tags删掉就完事了（其实是tags的文件里面没有相对应的，所以就上传不了）</p><h3 id="2-操作符"><a href="#2-操作符" class="headerlink" title="2. 操作符"></a>2. 操作符</h3><p>其次是一些操作符不清楚，但是现在还是熟练多了（服了）</p><h3 id="3-图片"><a href="#3-图片" class="headerlink" title="3. 图片"></a>3. 图片</h3><p>再者就是图片插入，用HTML的方法img但是加载不出来，很蛋疼</p><h2 id="近期的学习"><a href="#近期的学习" class="headerlink" title="近期的学习"></a><b style="color:blue">近期的学习</b></h2><h3 id="1-考试"><a href="#1-考试" class="headerlink" title="1. 考试"></a>1. 考试</h3><p>离谱的就是快要信导考试了，历史也要考试，新知识的学习可能会放慢，优先应付考试（手动滑稽）</p><h3 id="2-作业"><a href="#2-作业" class="headerlink" title="2. 作业"></a>2. 作业</h3><p>我***，算了，我是个儒雅随和的人，这么多无关紧要的作业，真的浪费时间，但是又不得不做，唉</p><h3 id="3-在看的书和计划看的书"><a href="#3-在看的书和计划看的书" class="headerlink" title="3. 在看的书和计划看的书"></a>3. 在看的书和计划看的书</h3><p>汇编、算法（紫书）、Java（神级乱入）（emmm都了解一点应该没大问题吧）</p><p>暂时也就这些吧，会定期整理分析自己的现状滴</p>]]></content>
      
      
      
        <tags>
            
            <tag> 成长记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rule Taking</title>
      <link href="/2019/12/16/Rule-Taking-0/"/>
      <url>/2019/12/16/Rule-Taking-0/</url>
      
        <content type="html"><![CDATA[<h1 id="尺取法-Rule-Taking"><a href="#尺取法-Rule-Taking" class="headerlink" title="尺取法 (Rule Taking)"></a>尺取法 (Rule Taking)</h1><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a><b style="color:green">常见用法</b></h2><p>一个数组中寻找长度最（小 / 大）的一段满足和最大或者大于某一个定值</p><h2 style="color:green">主要思想</h2>当 a1 , a2 , a3 ...... an 满足和 >= S，得到一个区间长度 n，那么去掉开头 a1，剩下 a2 , a3 ... 判断是否满足 >= S，<b style="color:red">如果满足</b>，那么区间长度更新，<b style="color:red">如果不满足</b>，那么尾部向后延展，判断 a2 , a3 ...... a (n + 1) 是否满足条件，重复这样的操作<h2 id="理解与思考"><a href="#理解与思考" class="headerlink" title="理解与思考"></a><b style="color:green">理解与思考</b></h2><p>当一个区间<b style="color:blue">满足条件</b>时，那么去掉区间开头第一个数，得到新区间，判断新区间是否满足条件，如果不满足条件，那么区间末尾向后扩展，直到满足条件为止，这样就得到了很多满足条件的区间，再根据题意，在此之间进行选择，比如区间最长，区间最短啥的，这样跑一遍下来，时间复杂度只有 O (n)</p><h2 id="比如"><a href="#比如" class="headerlink" title="比如"></a><b style="color:purple">比如</b></h2><p>给出 T 组数据，每组数据有 n 个数，并且每次给你一个 s 值，求最小的满足相加大于 s 的连续子序列的长度</p><p>详情请前往<a href="http://poj.org/problem?id=3061" target="_blank" rel="noopener">POJ3061</a></p><p>下面贴代码（C语言）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>]; <span class="comment">//定义一个数组来储存每组的数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);  <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">int</span> k = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>; <span class="comment">//清零操作</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (m &lt; s &amp;&amp; v &lt; n)</span><br><span class="line">            m = m + a[++v];  <span class="comment">//从第一个数开始增加，直到和大于等于 s 或者在 v 大于等于 n 的时候还是要小，就结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (m &lt; s)  <span class="comment">//判断和是否大于s,其实就是看整个数段总和是否大于s，如果不就跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; v - u)  <span class="comment">// u 作为数段的前标，v 作为数段的后标，v - u 就是数段的长度</span></span><br><span class="line">            k = v - u; <span class="comment">//取小的</span></span><br><span class="line">        m = m - a[u++]; <span class="comment">//在确定 s 比现在的和小后，从前面开始缩短数段，再进行循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == n + <span class="number">1</span>) <span class="comment">//这是所有数的和都比 s 小的情况</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k);  <span class="comment">//输出</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="有点想说的"><a href="#有点想说的" class="headerlink" title="有点想说的"></a><b style="color:orange">有点想说的</b></h1><p>emm第一个传上来的学习的……emm今晚去参加了元旦晚会的二审，没什么时间学习了，惭愧，然后就是报名了明年的蓝桥杯，需要准备（毕竟交了300嗷嗷嗷嗷），所以整理了一个算法专栏，回顾以前学的，更新新学习的，emm暂时也就这些了，我会坚持下去嗷。（话说博客真香哇）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello everyone</title>
      <link href="/2019/12/15/Hello-everyone/"/>
      <url>/2019/12/15/Hello-everyone/</url>
      
        <content type="html"><![CDATA[<h1 id="关于这个博客"><a href="#关于这个博客" class="headerlink" title="关于这个博客"></a>关于这个博客</h1><p>首先，要感谢<a href="https://lemonprefect.cn/" target="_blank" rel="noopener">Lemon</a>的技术支持，在创建了这个博客的时候我已经入大学三个月了，这个博客我会用来记录自己的一些学习经历，平时的刷题的一些报告（坑？），算法之类的，希望可以多向大佬们学习，最后争取超越他们。</p><h1 id="当下"><a href="#当下" class="headerlink" title="当下"></a>当下</h1><p>新生赛发挥不错，进入了网安组，承蒙老师学长厚爱，和同届大佬们的谦让，我有幸成为了19级组长，</p><p>希望与大家一同努力进步，誓必不辜负大家的信任。</p><h1 id="将来的想法"><a href="#将来的想法" class="headerlink" title="将来的想法"></a>将来的想法</h1><p>网安组是两个方向，web和pwn，说实在的我现在两个都挺感兴趣，所以还在思考，至于其它的高数英语之类的学习太尼玛蛋疼了，就尼玛离谱，还有历史什么的，很让人头大，总之，先学着就完事了。</p><p style="color:red">感谢你来到了这个小地方.</p>![程序员嘛，也还行](D:\shit\source\_posts\Hello-everyone\kPlYAP.jpg)]]></content>
      
      
      
        <tags>
            
            <tag> 成长记录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
