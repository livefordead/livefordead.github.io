<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Live for dead</title>
  
  <subtitle>YJ my love</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://livefordead.github.io/"/>
  <updated>2020-01-09T14:17:59.692Z</updated>
  <id>http://livefordead.github.io/</id>
  
  <author>
    <name>livefordead</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Binary tree</title>
    <link href="http://livefordead.github.io/2020/01/09/Binary-tree/"/>
    <id>http://livefordead.github.io/2020/01/09/Binary-tree/</id>
    <published>2020-01-09T14:17:59.000Z</published>
    <updated>2020-01-09T14:17:59.692Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Quick Select</title>
    <link href="http://livefordead.github.io/2020/01/09/Quick-Select/"/>
    <id>http://livefordead.github.io/2020/01/09/Quick-Select/</id>
    <published>2020-01-09T14:16:14.000Z</published>
    <updated>2020-01-09T14:16:14.681Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Quick Sort</title>
    <link href="http://livefordead.github.io/2020/01/09/Quick-Sort/"/>
    <id>http://livefordead.github.io/2020/01/09/Quick-Sort/</id>
    <published>2020-01-09T14:16:05.000Z</published>
    <updated>2020-01-09T14:31:29.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是啥，是一个很顶的排序，二话不多说，上代码以示友好</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基值在一个区块中，左边的数要小，右边的数要大*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>];  <span class="comment">//定义长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Quick_patition</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;  <span class="comment">//申明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span>  <span class="comment">//交换数组中下标为u、v的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = a[u];</span><br><span class="line">a[u] = a[v];</span><br><span class="line">a[v] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>  <span class="comment">//对当前区块（从left到right这一段）进行操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (right - left &lt;= <span class="number">0</span>)  <span class="comment">//如果该区块的长度已经小于等于 0，结束对这个区块的操作</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> pivot = Quick_patition(left, right);  <span class="comment">//得到这个区块的基值所在的位置</span></span><br><span class="line">Quick_Sort(left, pivot - <span class="number">1</span>);  <span class="comment">//对这一个区块中分出来的左区块进行操作</span></span><br><span class="line">Quick_Sort(pivot + <span class="number">1</span>, right);  <span class="comment">//对这一个区块分出来的有区块进行操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Quick_patition</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>  <span class="comment">//left是左标在数组的小标，right是右标在数组的下标（这个函数用以得到基值在当前区块的位置）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> base = right--;  <span class="comment">//定义区块的基值为最右边的数，base为基值所在的下标</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)  <span class="comment">//只有左标移动到了右标的位置处才会结束循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (a[left] &lt; a[base])  <span class="comment">//先移动左标，比较左标与基值，如果左标小于基值，左标右移，直到左标大于等于基值</span></span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">while</span> (a[right] &gt; a[base])  <span class="comment">//再移动右标，比较右标与基值，如果右标大于基值，右标左移，直到右标小于等于基值</span></span><br><span class="line">right--;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)  <span class="comment">//如果左标已经移动到了右标处甚至右标的右边，则结束</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//如果左标还没有移动到右标的位置，就交换左标与右标</span></span><br><span class="line">swap(left, right);</span><br><span class="line">&#125;</span><br><span class="line">swap(left, base);  <span class="comment">//交换左标与基值，使基值位于该区块中间</span></span><br><span class="line"><span class="keyword">return</span> left;  <span class="comment">//返还左标的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">//数组中值个数</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//赋值</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">Quick_Sort(<span class="number">0</span>, n - <span class="number">1</span>);  <span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;p&gt;快速排序是啥，是一个很顶的排序，二话不多说，上代码以示友好&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hash table</title>
    <link href="http://livefordead.github.io/2020/01/09/Hash-table/"/>
    <id>http://livefordead.github.io/2020/01/09/Hash-table/</id>
    <published>2020-01-09T14:15:41.000Z</published>
    <updated>2020-01-09T14:15:41.372Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Queue</title>
    <link href="http://livefordead.github.io/2020/01/09/Queue/"/>
    <id>http://livefordead.github.io/2020/01/09/Queue/</id>
    <published>2020-01-09T14:15:07.000Z</published>
    <updated>2020-01-09T14:15:07.848Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Stack</title>
    <link href="http://livefordead.github.io/2020/01/09/Stack/"/>
    <id>http://livefordead.github.io/2020/01/09/Stack/</id>
    <published>2020-01-09T14:14:43.000Z</published>
    <updated>2020-01-09T14:14:43.477Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linked list</title>
    <link href="http://livefordead.github.io/2019/12/17/Linked-list/"/>
    <id>http://livefordead.github.io/2019/12/17/Linked-list/</id>
    <published>2019-12-17T05:12:24.000Z</published>
    <updated>2020-01-09T15:36:55.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>基础概念不需要了，就总结一下链表相关操作吧（网上博客里的大佬们都说链表是很简单的【手动滑稽】）</p><ol><li>建立</li><li>输出</li><li>查找</li><li>修改</li><li>插入</li><li>删除</li><li>倒置</li><li>粉碎</li></ol><h2 id="建立与输出"><a href="#建立与输出" class="headerlink" title="建立与输出"></a>建立与输出</h2><p>要实现其他基本操作，首先先要创建一个链表，并能够将其输出，此处将建立与输出整合到一起</p><h3 id="尾插法创建单链表"><a href="#尾插法创建单链表" class="headerlink" title="尾插法创建单链表"></a><b style="color:blue">尾插法创建单链表</b></h3><p>这样生成的链表为正序</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;  <span class="comment">//数值域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">next</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这里是建立部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">head</span>;</span>  <span class="comment">//指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">p</span>, * <span class="title">q</span>;</span> <span class="comment">//声明指向当前结点的指针（用以创建节点），指向上一结点的指针（用以链接）</span></span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//定义一个整型的n作为这个链表的长度</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">head = (struct S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct S));  <span class="comment">//为头结点申请分配动态内存空间</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//将头结点中的指向下一节点的指针暂时性置为NULL</span></span><br><span class="line">q = head;  <span class="comment">//将头结点的指针赋值给“上一结点”，对于第二个结点来说，它的上一节点就是头结点，这就是这样赋值的意义</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">//循环 n 次</span></span><br><span class="line">&#123;</span><br><span class="line">p = (struct S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct S));  <span class="comment">//为当前结点申请分配动态内存空间（开辟一块新的“当前结点”）</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;p-&gt;data);  <span class="comment">//为数据域赋值</span></span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//将当前结点中的当中的指向下一结点的指针暂时性置为NULL，尽量这么做，因为这样最后一个结点的指针就能舒服地指向NULL</span></span><br><span class="line">q-&gt;next = p;  <span class="comment">//将上一结点的指向下一结点的指针指向当前结点</span></span><br><span class="line">q = p;  <span class="comment">//上一结点的指针指向当前结点为下一结点服务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是输出部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">visit</span>;</span>  <span class="comment">//创建一个指向当前结点的指针</span></span><br><span class="line">visit = head-&gt;next;  <span class="comment">//当前结点指向头结点指向的下一结点</span></span><br><span class="line"><span class="keyword">while</span> (visit != <span class="literal">NULL</span>)  <span class="comment">//如果当前结点的地址不为NULL的话</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visit-&gt;next == <span class="literal">NULL</span>)  <span class="comment">//判断当前结点屁股后面还有没有结点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, visit-&gt;data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, visit-&gt;data);</span><br><span class="line">visit = visit-&gt;next;  <span class="comment">//指向当前结点的指针指向下一结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是头插法</span></span><br></pre></td></tr></table></figure><h3 id="头插法创建单链表"><a href="#头插法创建单链表" class="headerlink" title="头插法创建单链表"></a><b style="color:red">头插法创建单链表</b></h3><p>这样生成的链表为逆序（其实和尾插法比起来只有中间有两三行的变动）</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;  <span class="comment">//数值域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">next</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这里是建立部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">head</span>;</span>  <span class="comment">//指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">p</span>, * <span class="title">q</span>;</span> <span class="comment">//声明指向当前结点的指针（用以创建节点），指向上一结点的指针（用以链接）</span></span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//定义一个整型的n作为这个链表的长度</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">head = (struct S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct S));  <span class="comment">//为头结点申请分配动态内存空间</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//将头结点中的指向下一节点的指针暂时性置为NULL</span></span><br><span class="line">q = head;  <span class="comment">//将头结点的指针赋值给“上一结点”，对于第二个结点来说，它的上一节点就是头结点，这就是这样赋值的意义</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">//循环 n 次</span></span><br><span class="line">&#123;</span><br><span class="line">p = (struct S*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct S));  <span class="comment">//为当前结点申请分配动态内存空间（开辟一块新的“当前结点”）</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;p-&gt;data);  <span class="comment">//为数据域赋值</span></span><br><span class="line">p-&gt;next = head-&gt;next;  <span class="comment">//新结点的 next 指向头指针所连接的指针</span></span><br><span class="line">head-&gt;next = p;  <span class="comment">//头结点的 next 指针指向新结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是输出部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">visit</span>;</span>  <span class="comment">//创建一个指向当前结点的指针</span></span><br><span class="line">visit = head-&gt;next;  <span class="comment">//当前结点指向头结点指向的下一结点</span></span><br><span class="line"><span class="keyword">while</span> (visit != <span class="literal">NULL</span>)  <span class="comment">//如果当前结点的地址不为NULL的话</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visit-&gt;next == <span class="literal">NULL</span>)  <span class="comment">//判断当前结点屁股后面还有没有结点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, visit-&gt;data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, visit-&gt;data);</span><br><span class="line">visit = visit-&gt;next;  <span class="comment">//指向当前结点的指针指向下一结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是头插法</span></span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>众所周知，链表没有像指针那样的下标，不支持随机访问，所以要查找某接待你，必须通过遍历的方式</p><p>就比如我希望定义一个函数，它可以实现：我输入一个值，它可以返还这个值在链表中的结点的位置，如果找不到就返还 -1</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(struct S* head, <span class="keyword">int</span> r)</span>  <span class="comment">//head 即是头结点，r 是要查找的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">temp</span>;</span>  <span class="comment">//定义用以遍历的指针</span></span><br><span class="line">temp = head;  <span class="comment">//指针首先指向头结点</span></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>; <span class="comment">//结点所在的位置</span></span><br><span class="line"><span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)  <span class="comment">//判断</span></span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;  <span class="comment">//指针后移</span></span><br><span class="line"><span class="keyword">if</span> (r == temp-&gt;data)</span><br><span class="line"><span class="keyword">return</span> t;  <span class="comment">//其实这里返还的只有首位置，但是没大问题</span></span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//显然没有找到，返还 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>如果想要修改某一结点的数值域，首先要遍历找到这个结点，然后直接修改</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Replace</span><span class="params">(struct S* head, <span class="keyword">int</span> u, <span class="keyword">int</span> v)</span>  <span class="comment">//head 即是头结点，u 是节点位置，v 是修改后的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">temp</span>;</span>  <span class="comment">//定义用以遍历的指针</span></span><br><span class="line">temp = head-&gt;next;  <span class="comment">//指针首先指向开始的结点（头节点里无东西）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; u; i++)</span><br><span class="line">temp = temp-&gt;next;  <span class="comment">//指针后移</span></span><br><span class="line">temp-&gt;data = v;  <span class="comment">//直接修改</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>有三种插入的方法：</p><ol><li>头插</li><li>尾插</li><li>插入中间</li></ol><p>但是插入的方法差不多，都是先将新结点的 next 指向插入节点后的那个结点，然后将插入结点前的那个结点的 next 指向插入结点</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(struct S* head, <span class="keyword">int</span> u, <span class="keyword">int</span> v)</span>  <span class="comment">//head 即是头结点，u 是插入的位置，v 是传入的数值域</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">temp</span>;</span>  <span class="comment">//定义用以遍历的指针</span></span><br><span class="line">temp = head;  <span class="comment">//指针首先指向头结点</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((temp != <span class="literal">NULL</span>) &amp;&amp; (i &lt; u - <span class="number">1</span>))  <span class="comment">//首先找到插入结点的上一个结点，即第(u - 1)个结点</span></span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((temp == <span class="literal">NULL</span>) || (i &gt; u - <span class="number">1</span>))  <span class="comment">//错误处理：链表为空或者不存在这个插入的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error!\n"</span>);  <span class="comment">//输出错误信息</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* _<span class="title">new</span> = (<span class="title">struct</span> <span class="title">S</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">S</span>));</span>  <span class="comment">//创建新结点_new</span></span><br><span class="line">_new-&gt;data = v;  <span class="comment">//赋值给插入的新结点的数据域</span></span><br><span class="line">_new-&gt;next = temp-&gt;next;  <span class="comment">//新结点的 next 指针指向插入位置后的结点</span></span><br><span class="line">temp-&gt;next = _new;  <span class="comment">//插入位置前的结点的 next 指针指向新结点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>当删除结点的时候，主要是两步操作：（一定要按顺序！）</p><ol><li>被删除结点的前一个结点的 next 指针指向被删除结点之后的结点（即将被删除结点“孤立出来”）</li><li>释放被删除结点的内存</li></ol><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(struct S* head, <span class="keyword">int</span> u, <span class="keyword">int</span>* v)</span>  <span class="comment">//head 即是头结点，u 是删除的位置，v 用以保存被删除节点的数值域</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">temp</span>;</span>  <span class="comment">//定义用以遍历的指针</span></span><br><span class="line">temp = head;  <span class="comment">//指针首先指向头结点</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((temp != <span class="literal">NULL</span>) &amp;&amp; (i &lt; u - <span class="number">1</span>))  <span class="comment">//就像插入一样，首先找到插入结点的上一个结点，即第(u - 1)个结点</span></span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((temp == <span class="literal">NULL</span>) || (i &gt; u - <span class="number">1</span>))  <span class="comment">//错误处理：链表为空或者不存在这个插入的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error!\n"</span>);  <span class="comment">//输出错误信息（就像插入一样，依然需要错误处理）</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* _<span class="title">del</span> = <span class="title">temp</span>-&gt;<span class="title">next</span>;</span>  <span class="comment">//定义 _del 指向被删除的结点</span></span><br><span class="line">*v = _del-&gt;data;  <span class="comment">//保存被删除结点的数值域</span></span><br><span class="line">temp-&gt;next = _del-&gt;next;  <span class="comment">//被删除结点的上一个结点指向被删除结点的下一个节点</span></span><br><span class="line"><span class="built_in">free</span>(_del);  <span class="comment">//手动释放这个节点，防止内存泄漏</span></span><br><span class="line">_del = <span class="literal">NULL</span>;  <span class="comment">//指向空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="倒置"><a href="#倒置" class="headerlink" title="倒置"></a>倒置</h2><p>倒置算是这几种基本操作里面比较麻烦、难得理解的一个操作了</p><p>首先让头节点与第一个元素节点断开，但是要注意在断开之前需要用p指针指向第一个元素节点来保存第一个元素节点的位置，然后再断开。在这里有一个指针q指向一个指针域为空的节点，这个节点用来做为链表反转后的最后一个节点</p><p>让第二个元素节点的指针从指向第三个元素节点变为指向第一个元素节点，以此类推，直至指针p指向原链表最后一个元素</p><p>p指针指向NULL时，让原头节点的指针域指向原来最后一个元素节点。此时链表倒置已完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reserve</span><span class="params">(struct S* head)</span>  <span class="comment">//head 即是头结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">temp</span>;</span>  <span class="comment">//temp 暂时储存 p 所指向结点的下一个结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">p</span>, * <span class="title">q</span>;</span>  <span class="comment">//p 用以遍历除开头结点之外的所有结点，并对它们进行操作</span></span><br><span class="line">p = head-&gt;next;  <span class="comment">//p 指向 head 的下一个结点</span></span><br><span class="line">q = <span class="literal">NULL</span>;  <span class="comment">//q 用以作为未操作完的新链表的临时头结点（除开头结点外的其他结点再进行操作时的头结点的）</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)  <span class="comment">//在 p 完成对尾结点的操作之后结束</span></span><br><span class="line">&#123;</span><br><span class="line">temp = p-&gt;next;  <span class="comment">//用temp 暂时储存 p 所指向结点的下一个结点，防止丢失后面的结点链</span></span><br><span class="line">p-&gt;next = q;  <span class="comment">//p 指向 q</span></span><br><span class="line">q = p;  <span class="comment">//q 指向 p 所指向的结点，即新的头结点</span></span><br><span class="line">p = temp;  <span class="comment">//更新 p，使 p 指向下一个结点</span></span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = q;  <span class="comment">//头结点 head 指向 q</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="粉碎"><a href="#粉碎" class="headerlink" title="粉碎"></a>粉碎</h2><p>粉碎也不能就只把头指针断掉，还要一个一个释放掉内存并清空嗷</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Crush</span><span class="params">(struct S* head)</span>  <span class="comment">//head 即使头结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>* <span class="title">temp</span>;</span>  <span class="comment">//temp 暂时储存头结点所指的结点</span></span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">NULL</span>)  <span class="comment">//head 为空的时候结束</span></span><br><span class="line">&#123;</span><br><span class="line">temp = head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(head);  <span class="comment">//释放</span></span><br><span class="line">head = temp;  <span class="comment">//新的头结点（即前一个头结点的下一个结点）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="骚操作"><a href="#骚操作" class="headerlink" title="骚操作"></a>骚操作</h2><h3 id="合并两个有序链表为一个新的有序链表"><a href="#合并两个有序链表为一个新的有序链表" class="headerlink" title="合并两个有序链表为一个新的有序链表"></a>合并两个有序链表为一个新的有序链表</h3><p>今天（2019.12.29）看见的，Leetcode上的大神写的，递归实现，太强了吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List_Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List_Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;  <span class="comment">//结构体</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct List_Node* <span class="title">Merge_Lists</span> <span class="params">( struct List_Node* L1, struct List_Node* L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> L2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> L1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>(L1-&gt;val &lt;= L2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            L1-&gt;next = Merge_Lists(L1-&gt;next, L2);</span><br><span class="line">            <span class="keyword">return</span> L1;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">        L2-&gt;next = Merge_Lists(L1, L2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> L2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表相关"><a href="#双向链表相关" class="headerlink" title="双向链表相关"></a>双向链表相关</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;p&gt;基础概念不需要了，就总结一下链表相关操作吧（网上博客里的大佬们都说链表是很简单的【手动滑稽】）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="思考与学习" scheme="http://livefordead.github.io/tags/%E6%80%9D%E8%80%83%E4%B8%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>About Struct</title>
    <link href="http://livefordead.github.io/2019/12/17/About-Struct/"/>
    <id>http://livefordead.github.io/2019/12/17/About-Struct/</id>
    <published>2019-12-17T00:44:34.000Z</published>
    <updated>2019-12-17T01:36:44.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>写这个主要是之前第一次用结构体AC了一道题，就巨兴奋，感觉想要记录下来，然后结构体在刷题中的确蛮好玩的，挺香，接下来是我之前刷过的两道题（应该会补充）</p><h2 id="HDU1004"><a href="#HDU1004" class="headerlink" title="HDU1004"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1004" target="_blank" rel="noopener">HDU1004</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有很多组测试，每一组首先给出一个数值，代表接下来出现的颜色个数，如果给出的数值为 0，则结束测试，每一组中，要你输出出现最多的颜色</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>每种不一样的颜色使用一个结构体储存（储存名字和数量），每次输入都对储存不同颜色的结构体数组进行一次遍历，使用strcmp判断是否这个颜色已经“记录在案”，如果没有存在则使用strcpy将其储存下来（记得第一次特判（I think））</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS  <span class="comment">//这个预处理命令加不加没必要，可以忽略一些警告的，比如VS2019中的安全性问题</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">20</span>];  <span class="comment">//a 作为当前颜色而存在</span></span><br><span class="line"><span class="keyword">char</span> b[<span class="number">20</span>];  <span class="comment">//b 储存数量最多的颜色</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> u[<span class="number">20</span>];  <span class="comment">//储存颜色名字</span></span><br><span class="line"><span class="keyword">int</span> v;       <span class="comment">//储存当前该颜色的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//多少组数据</span></span><br><span class="line"><span class="keyword">int</span> t;  </span><br><span class="line"><span class="keyword">int</span> m;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> <span class="title">k</span>[1005];</span>  </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="number">0</span>;  <span class="comment">//记录颜色种类</span></span><br><span class="line">m = <span class="number">0</span>;  <span class="comment">//每种颜色数量的最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//这组共输入 n 个颜色</span></span><br><span class="line">&#123;</span><br><span class="line">scanf_s(<span class="string">"%s"</span>, &amp;a, <span class="keyword">sizeof</span>(a));  <span class="comment">//更为安全的定义字符数组的方式</span></span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">0</span>)  <span class="comment">//此处判断第一个输入的颜色</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(k[<span class="number">0</span>].u, a);  <span class="comment">//把第一个输入的字符录入结构体数组中</span></span><br><span class="line">k[<span class="number">0</span>].v = <span class="number">1</span>;  <span class="comment">//该颜色数量初始化为 1</span></span><br><span class="line">t++;  <span class="comment">//颜色种类 + 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; j++)  <span class="comment">//遍历已有的颜色</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(k[j].u, a) == <span class="number">0</span>)  <span class="comment">//如果这种颜色已经出现过，就只需要增加这种颜色的数量</span></span><br><span class="line">&#123;</span><br><span class="line">k[j].v++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j == t - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(k[t].u, a);  <span class="comment">//如果这种颜色没有出现过，就增加一个颜色种类</span></span><br><span class="line">k[t].v = <span class="number">1</span>;  <span class="comment">//该颜色数量初始化为 1</span></span><br><span class="line">t++;  <span class="comment">//该颜色种类 + 1</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)  <span class="comment">//遍历所有颜色</span></span><br><span class="line"><span class="keyword">if</span> (k[i].v &gt; m)  <span class="comment">//判断最大值</span></span><br><span class="line">&#123;</span><br><span class="line">m = k[i].v;  <span class="comment">//把当前颜色的最大值储存入 m</span></span><br><span class="line"><span class="built_in">strcpy</span>(b, k[i].u);  <span class="comment">//把当前数量最大的颜色储存入 b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, b);  <span class="comment">//输出最大值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HDU2550"><a href="#HDU2550" class="headerlink" title="HDU2550"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2550" target="_blank" rel="noopener">HDU2550</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>一开始给出一个值，代表接下来的测试组数，每组先输入一个数，代表每组有多少对数据（A,B），每对数据的意思是有箭身长度为 A 的箭 B 枝，（这一道题是新生赛前的热身赛里的一道题，很离谱，热身赛全部题目的题干都巨尼玛中二，一道最简单的求距离的题可以说得玄乎其玄），然后要你按照箭身长度输出每种弓箭，每种弓箭之间还要空行（需要结构体排序）</p><p>就比如A = 3，B = 4的话就要输出这种箭   &gt;+-+&gt;</p><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><p>这一道题的难点其实就只有结构体排序部分，只要结构体排序整出来了就很简单嗷</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>  //定义结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">r</span><span class="params">(struct S x, struct S y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.u &lt; y.u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span>[50];</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s[i].u &gt;&gt; s[i].v;</span><br><span class="line">        sort(s, s + n, r);  <span class="comment">//结构体排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i].v; j++)  <span class="comment">//输出部分（只要排好序了这一部分没得问题）</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&gt;+"</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s[i].u - <span class="number">2</span>; k++)</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"+&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h1&gt;&lt;p&gt;写这个主要是之前第一次用结构体AC了一道题，就巨兴奋，感觉想要记录下来，然后结构体在刷题中的确蛮好玩的，挺香，接下来是我之前刷过的两
      
    
    </summary>
    
    
    
      <category term="刷题" scheme="http://livefordead.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>九余</title>
    <link href="http://livefordead.github.io/2019/12/16/%E4%B9%9D%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    <id>http://livefordead.github.io/2019/12/16/%E4%B9%9D%E4%BD%99%E5%AE%9A%E7%90%86/</id>
    <published>2019-12-16T12:15:15.000Z</published>
    <updated>2019-12-16T12:30:30.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="九余定理"><a href="#九余定理" class="headerlink" title="九余定理"></a>九余定理</h1><p>九余定理是一个和数学有关的知识，可以了解一下</p><p>首先要介绍<b style="color:red">九余数的概念</b>：一个数的各位数字之和相加后得到的&lt;10的数字称为这个数（如果相加结果大于9，则继续各位相加）</p><p>然后是<b style="color:red">九余定理的定义</b>：一个数 x，他的每个位上的数加起来为 y，九余数为（y - 1）再对 9 求余然后加1，用 C 语言表示就是 ( y - 1 ) % 9 + 1</p><p>emmm，就是说一个数，如果我要求它的九余数，怎么求呢，这样求？</p><h4 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a><b style="color:green">代码一</b></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s, t;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> ((<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &amp;&amp; (n != <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">s = s + n % <span class="number">10</span>;</span><br><span class="line">n = n / <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s &lt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">n = s;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我第一次做的时候的代码，发现在处理较大的数时行不通，所以就换一种，再看看这种？</p><h4 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a><b style="color:green">代码二</b></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;x)&amp;&amp;(x[<span class="number">0</span>] != <span class="string">'0'</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; x[i]; ++i)</span><br><span class="line">            t = t + x[i] - <span class="string">'0'</span>;</span><br><span class="line">        t = t % <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t)</span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">if</span>(x[<span class="number">0</span>] == <span class="string">'0'</span>)                             <span class="comment">//这里是特判 0 的情况</span></span><br><span class="line">                t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就诞生了这个代码，没办法，因为处理较大的数的时候只好用字符来存储，但是还是不够简洁，下面就是九余定理</p><h4 id="代码三"><a href="#代码三" class="headerlink" title="代码三"></a><b style="color:green">代码三</b></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> n[<span class="number">100000</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>((<span class="built_in">scanf</span>(<span class="string">"%s"</span>,n)!=EOF)&amp;&amp;n[<span class="number">0</span>]!=<span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(n); i++)</span><br><span class="line">            s = s + n[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (s - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;九余定理&quot;&gt;&lt;a href=&quot;#九余定理&quot; class=&quot;headerlink&quot; title=&quot;九余定理&quot;&gt;&lt;/a&gt;九余定理&lt;/h1&gt;&lt;p&gt;九余定理是一个和数学有关的知识，可以了解一下&lt;/p&gt;
&lt;p&gt;首先要介绍&lt;b style=&quot;color:red&quot;&gt;九余数的概念
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>My opinion</title>
    <link href="http://livefordead.github.io/2019/12/16/My-opinion/"/>
    <id>http://livefordead.github.io/2019/12/16/My-opinion/</id>
    <published>2019-12-16T06:46:40.000Z</published>
    <updated>2019-12-17T02:44:46.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对管理系统的一些看法"><a href="#对管理系统的一些看法" class="headerlink" title="对管理系统的一些看法"></a>对管理系统的一些看法</h1><p>整个这个幺蛾子呢，主要是平时学习学累了的时候就可以看看别的组的任务，还挺香的。</p><h2 id="主体方面"><a href="#主体方面" class="headerlink" title="主体方面"></a><b style="color:gold">主体方面</b></h2><p>无论是哪个管理系统，都不可能脱离注册、登录、信息修改、设置管理员是不是，还有美观界面等等其它骚操作，所以我们分成点一个一个地解决，一步一步来</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a><b style="color:red">注册</b></h3><p>注册，首先我们需要在用户<b style="color:cyan">注册成功的同时</b>创建一个<b style="color:red">专属于该用户</b>的文本文档用以储存该用户的所有信息（下面就不采用调用函数的形式了）</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>] = <span class="string">""</span>;  <span class="comment">//用户名</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">word</span>[<span class="number">20</span>] = <span class="string">""</span>;  <span class="comment">//密码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE* fp;  <span class="comment">//这个你学文件里面应该有滴</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">user</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">scanf_s(<span class="string">"%s"</span>, user.name, <span class="keyword">sizeof</span>(user.name));  <span class="comment">//安全性</span></span><br><span class="line">fp = fopen(user.name, <span class="string">"r"</span>);  <span class="comment">//以只读的方式打开这个文件，fp指向以user.name为名的文件，如果没有这个文件，则fp指向NULL</span></span><br><span class="line"><span class="keyword">if</span> (fp != <span class="literal">NULL</span>)  <span class="comment">//说明已经存在这个文件，就不可以用这个用户名注册，进行你想要的操作</span></span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//说明这个用户名可用，其实在前面还可以加上判断用户名长度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//然后是输入密码并确认密码的操作</span></span><br><span class="line">&#125;</span><br><span class="line">fp = fopen(user.name, <span class="string">"w"</span>);  <span class="comment">//user.name写入文件，user.name是文件名，要是没有成功，fp指向NULL</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)  <span class="comment">//显然注册失败</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//注册成功</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//任意发挥，比如输出一些话</span></span><br><span class="line"><span class="keyword">if</span> (fwrite(&amp;user, <span class="keyword">sizeof</span>(User), <span class="number">1</span>, fp) != <span class="number">1</span>)  <span class="comment">/*第一个是指向结构体的地址，第二个是写入内容的大小，</span></span><br><span class="line"><span class="comment">   第三个是数据项的个数（这里我只要写入一个结构体，所以是 1），第四个是目标文件指针</span></span><br><span class="line"><span class="comment">   返还值是实际的写入数据项的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//要是返还值不是 1，就说明写入文件错误，可以输出一个提示，然后退出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到此为止，这就是注册的基本架构啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a><b style="color:red">登录</b></h3><p>要登陆，首先是要<b style="color:red">建立在这个用户创建了的基础上</b>，就是说我要<b style="color:blue">可以找到</b>属于这个用户的文本文档，要是找不到，就说明不存在这个用户，就可以提示并结束，然后找到了用户之后需要比较原始密码与输入密码（可以加入输错三次锁死或退出之类的）</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>] = <span class="string">""</span>;  <span class="comment">//用户名</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">word</span>[<span class="number">20</span>] = <span class="string">""</span>;  <span class="comment">//密码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE* fp;  <span class="comment">//这个你学文件里面应该有滴</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">user</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  <span class="comment">// 好啦，接下来是在有了注册的基础上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> _id[<span class="number">20</span>]; <span class="comment">//用以输入的用户名</span></span><br><span class="line"><span class="keyword">char</span> _pass[<span class="number">20</span>];  <span class="comment">//用以输入的密码</span></span><br><span class="line">scanf_s(<span class="string">"%s"</span>, _id, <span class="keyword">sizeof</span>(_id));</span><br><span class="line">fp = fopen(_id, <span class="string">"r+"</span>);  <span class="comment">//只读，看是不是存在这个用户名</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)  <span class="comment">//显然不存在</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//进行你想要的操作</span></span><br><span class="line">&#125;</span><br><span class="line">fread(&amp;user, <span class="keyword">sizeof</span>(User), <span class="number">1</span>, fp);  <span class="comment">//从fp所指向的文件处读取user的信息</span></span><br><span class="line">scanf_s(<span class="string">"%s"</span>, &amp;_pass, <span class="keyword">sizeof</span>(_pass));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(user.<span class="keyword">word</span>, _pass) != <span class="number">0</span>)  <span class="comment">//比较正确密码与输入的密码</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输错了，咋办</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对啦，登陆成功啦</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(未完……前面也还需要补充)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对管理系统的一些看法&quot;&gt;&lt;a href=&quot;#对管理系统的一些看法&quot; class=&quot;headerlink&quot; title=&quot;对管理系统的一些看法&quot;&gt;&lt;/a&gt;对管理系统的一些看法&lt;/h1&gt;&lt;p&gt;整个这个幺蛾子呢，主要是平时学习学累了的时候就可以看看别的组的任务，还挺香的
      
    
    </summary>
    
    
    
      <category term="思考与学习" scheme="http://livefordead.github.io/tags/%E6%80%9D%E8%80%83%E4%B8%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>汇编</title>
    <link href="http://livefordead.github.io/2019/12/16/%E6%B1%87%E7%BC%96/"/>
    <id>http://livefordead.github.io/2019/12/16/%E6%B1%87%E7%BC%96/</id>
    <published>2019-12-16T04:54:40.000Z</published>
    <updated>2019-12-17T02:44:47.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PWN——汇编"><a href="#PWN——汇编" class="headerlink" title="PWN——汇编"></a>PWN——汇编</h1><p>最近在了解PWN和WEB，PWN的话先是说搞汇编，就学一下，我寻思掌握了的基础知识也没有丢上来的必要，就记录一下遇到的坎和重难点之类的吧</p><h2 id="1-一些基本概念"><a href="#1-一些基本概念" class="headerlink" title="1. 一些基本概念"></a><b style="color:red">1. 一些基本概念</b></h2><p><strong>a.</strong> 汇编语言与机器语言的区别在于<em>指令的表示方式</em></p><p><strong>b.</strong> 汇编语言由 3 类指令组成：</p><ol><li>汇编指令：机器码的助记符，有对应的机器码</li><li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li><li>其他符号：如 +、-、*、/ 等，由编译器识别，没有对应的机器码</li></ol><p>(未完……….)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PWN——汇编&quot;&gt;&lt;a href=&quot;#PWN——汇编&quot; class=&quot;headerlink&quot; title=&quot;PWN——汇编&quot;&gt;&lt;/a&gt;PWN——汇编&lt;/h1&gt;&lt;p&gt;最近在了解PWN和WEB，PWN的话先是说搞汇编，就学一下，我寻思掌握了的基础知识也没有丢上来的必要
      
    
    </summary>
    
    
    
      <category term="思考与学习" scheme="http://livefordead.github.io/tags/%E6%80%9D%E8%80%83%E4%B8%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>HDU 2054</title>
    <link href="http://livefordead.github.io/2019/12/16/HDU-2054/"/>
    <id>http://livefordead.github.io/2019/12/16/HDU-2054/</id>
    <published>2019-12-15T20:10:29.000Z</published>
    <updated>2019-12-18T05:51:11.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HDU2054"><a href="#HDU2054" class="headerlink" title="HDU2054 !"></a><b style="color:cyan">HDU2054 !</b></h1><h2 id="A-B"><a href="#A-B" class="headerlink" title="A==B?"></a><b style="color:blue">A==B?</b></h2><h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2054" target="_blank" rel="noopener">HDU2054</a>这道题，好久之前做的一道挺有意思的水题，这一题从暑假开始一直A到开学后十几天，终于是做出来了，一开始太天真地以为它真的就是道下饭的题（虽然的确挺水），结果自己的操作是真的下饭，很离谱，但是后来还是莫名想通了，去搜了自己要的东西就顺利做了出来。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>虽然是比较两个数是否相等，但是并不是让你比较两个整形，这本质上其实还是道大数题，CSDN、博客园里面有蛮多人的代码都考虑太多，主要有这几种情况：</p><p><strong>·</strong> 要考虑小数点和其后的无效零</p><p><strong>·</strong> 不要考虑前导零</p><p><strong>·</strong> 不要考虑正负号</p><p>所以可以开一个字符数组，分别检索小数点存在与否（可以使用 strstr 或者 for 循环遍历查找），然后将其后的 0 全部转化为 ‘\0’ （终止符），最后将小数点转化为 ‘\0’ （终止符），最后用 strcmp比较即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S</span><span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    l = <span class="built_in">strlen</span>(s);  <span class="comment">//取字符数组的长度</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(s, <span class="string">"."</span>))  <span class="comment">//使用strstr查找是否存在小数点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l - <span class="number">1</span>; s[i] == <span class="string">'0'</span>; i--)  <span class="comment">//从最后一位向前去除所有后置无效零</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = <span class="string">'\0'</span>;</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[l - <span class="number">1</span>] == <span class="string">'.'</span>)  <span class="comment">//去除小数点</span></span><br><span class="line">        s[l - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(scanf_s(<span class="string">"%s %s"</span>, &amp;a, &amp;b, <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(b)) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        S(a);</span><br><span class="line">        S(b);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a, b) == <span class="number">0</span>)  <span class="comment">//比较</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HDU2054&quot;&gt;&lt;a href=&quot;#HDU2054&quot; class=&quot;headerlink&quot; title=&quot;HDU2054 !&quot;&gt;&lt;/a&gt;&lt;b style=&quot;color:cyan&quot;&gt;HDU2054 !&lt;/b&gt;&lt;/h1&gt;&lt;h2 id=&quot;A-B&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
    
      <category term="刷题" scheme="http://livefordead.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Some Complaing</title>
    <link href="http://livefordead.github.io/2019/12/16/Some-Complaing/"/>
    <id>http://livefordead.github.io/2019/12/16/Some-Complaing/</id>
    <published>2019-12-15T19:44:57.000Z</published>
    <updated>2019-12-15T19:59:01.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抱怨亿句"><a href="#抱怨亿句" class="headerlink" title="抱怨亿句"></a>抱怨亿句</h1><p>啊啊啊，我搞了几个小时，终于会自己上传文章了，之前要搞那个尺取法，这会儿舒服了我去</p><h2 id="我遇到了的困难"><a href="#我遇到了的困难" class="headerlink" title="我遇到了的困难"></a><b style="color:red">我遇到了的困难</b></h2><h3 id="1-Tags"><a href="#1-Tags" class="headerlink" title="1. Tags"></a>1. Tags</h3><p>首先是GIT找不到上传文件，后来把tags删掉就完事了（其实是tags的文件里面没有相对应的，所以就上传不了）</p><h3 id="2-操作符"><a href="#2-操作符" class="headerlink" title="2. 操作符"></a>2. 操作符</h3><p>其次是一些操作符不清楚，但是现在还是熟练多了（服了）</p><h3 id="3-图片"><a href="#3-图片" class="headerlink" title="3. 图片"></a>3. 图片</h3><p>再者就是图片插入，用HTML的方法img但是加载不出来，很蛋疼</p><h2 id="近期的学习"><a href="#近期的学习" class="headerlink" title="近期的学习"></a><b style="color:blue">近期的学习</b></h2><h3 id="1-考试"><a href="#1-考试" class="headerlink" title="1. 考试"></a>1. 考试</h3><p>离谱的就是快要信导考试了，历史也要考试，新知识的学习可能会放慢，优先应付考试（手动滑稽）</p><h3 id="2-作业"><a href="#2-作业" class="headerlink" title="2. 作业"></a>2. 作业</h3><p>我***，算了，我是个儒雅随和的人，这么多无关紧要的作业，真的浪费时间，但是又不得不做，唉</p><h3 id="3-在看的书和计划看的书"><a href="#3-在看的书和计划看的书" class="headerlink" title="3. 在看的书和计划看的书"></a>3. 在看的书和计划看的书</h3><p>汇编、算法（紫书）、Java（神级乱入）（emmm都了解一点应该没大问题吧）</p><p>暂时也就这些吧，会定期整理分析自己的现状滴</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;抱怨亿句&quot;&gt;&lt;a href=&quot;#抱怨亿句&quot; class=&quot;headerlink&quot; title=&quot;抱怨亿句&quot;&gt;&lt;/a&gt;抱怨亿句&lt;/h1&gt;&lt;p&gt;啊啊啊，我搞了几个小时，终于会自己上传文章了，之前要搞那个尺取法，这会儿舒服了我去&lt;/p&gt;
&lt;h2 id=&quot;我遇到了的困难&quot;
      
    
    </summary>
    
    
    
      <category term="成长记录" scheme="http://livefordead.github.io/tags/%E6%88%90%E9%95%BF%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Rule Taking</title>
    <link href="http://livefordead.github.io/2019/12/16/Rule-Taking-0/"/>
    <id>http://livefordead.github.io/2019/12/16/Rule-Taking-0/</id>
    <published>2019-12-15T18:37:04.000Z</published>
    <updated>2019-12-17T02:37:04.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="尺取法-Rule-Taking"><a href="#尺取法-Rule-Taking" class="headerlink" title="尺取法 (Rule Taking)"></a>尺取法 (Rule Taking)</h1><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a><b style="color:green">常见用法</b></h2><p>一个数组中寻找长度最（小 / 大）的一段满足和最大或者大于某一个定值</p><h2 style="color:green">主要思想</h2>当 a1 , a2 , a3 ...... an 满足和 >= S，得到一个区间长度 n，那么去掉开头 a1，剩下 a2 , a3 ... 判断是否满足 >= S，<b style="color:red">如果满足</b>，那么区间长度更新，<b style="color:red">如果不满足</b>，那么尾部向后延展，判断 a2 , a3 ...... a (n + 1) 是否满足条件，重复这样的操作<h2 id="理解与思考"><a href="#理解与思考" class="headerlink" title="理解与思考"></a><b style="color:green">理解与思考</b></h2><p>当一个区间<b style="color:blue">满足条件</b>时，那么去掉区间开头第一个数，得到新区间，判断新区间是否满足条件，如果不满足条件，那么区间末尾向后扩展，直到满足条件为止，这样就得到了很多满足条件的区间，再根据题意，在此之间进行选择，比如区间最长，区间最短啥的，这样跑一遍下来，时间复杂度只有 O (n)</p><h2 id="比如"><a href="#比如" class="headerlink" title="比如"></a><b style="color:purple">比如</b></h2><p>给出 T 组数据，每组数据有 n 个数，并且每次给你一个 s 值，求最小的满足相加大于 s 的连续子序列的长度</p><p>详情请前往<a href="http://poj.org/problem?id=3061" target="_blank" rel="noopener">POJ3061</a></p><p>下面贴代码（C语言）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>]; <span class="comment">//定义一个数组来储存每组的数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);  <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">int</span> k = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>; <span class="comment">//清零操作</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (m &lt; s &amp;&amp; v &lt; n)</span><br><span class="line">            m = m + a[++v];  <span class="comment">//从第一个数开始增加，直到和大于等于 s 或者在 v 大于等于 n 的时候还是要小，就结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (m &lt; s)  <span class="comment">//判断和是否大于s,其实就是看整个数段总和是否大于s，如果不就跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; v - u)  <span class="comment">// u 作为数段的前标，v 作为数段的后标，v - u 就是数段的长度</span></span><br><span class="line">            k = v - u; <span class="comment">//取小的</span></span><br><span class="line">        m = m - a[u++]; <span class="comment">//在确定 s 比现在的和小后，从前面开始缩短数段，再进行循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == n + <span class="number">1</span>) <span class="comment">//这是所有数的和都比 s 小的情况</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k);  <span class="comment">//输出</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有点想说的"><a href="#有点想说的" class="headerlink" title="有点想说的"></a><b style="color:orange">有点想说的</b></h1><p>emm第一个传上来的学习的……emm今晚去参加了元旦晚会的二审，没什么时间学习了，惭愧，然后就是报名了明年的蓝桥杯，需要准备（毕竟交了300嗷嗷嗷嗷），所以整理了一个算法专栏，回顾以前学的，更新新学习的，emm暂时也就这些了，我会坚持下去嗷。（话说博客真香哇）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;尺取法-Rule-Taking&quot;&gt;&lt;a href=&quot;#尺取法-Rule-Taking&quot; class=&quot;headerlink&quot; title=&quot;尺取法 (Rule Taking)&quot;&gt;&lt;/a&gt;尺取法 (Rule Taking)&lt;/h1&gt;&lt;h2 id=&quot;常见用法&quot;&gt;&lt;a 
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://livefordead.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello everyone</title>
    <link href="http://livefordead.github.io/2019/12/15/Hello-everyone/"/>
    <id>http://livefordead.github.io/2019/12/15/Hello-everyone/</id>
    <published>2019-12-15T07:47:48.000Z</published>
    <updated>2019-12-16T03:26:35.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于这个博客"><a href="#关于这个博客" class="headerlink" title="关于这个博客"></a>关于这个博客</h1><p>首先，要感谢<a href="https://lemonprefect.cn/" target="_blank" rel="noopener">Lemon</a>的技术支持，在创建了这个博客的时候我已经入大学三个月了，这个博客我会用来记录自己的一些学习经历，平时的刷题的一些报告（坑？），算法之类的，希望可以多向大佬们学习，最后争取超越他们。</p><h1 id="当下"><a href="#当下" class="headerlink" title="当下"></a>当下</h1><p>新生赛发挥不错，进入了网安组，承蒙老师学长厚爱，和同届大佬们的谦让，我有幸成为了19级组长，</p><p>希望与大家一同努力进步，誓必不辜负大家的信任。</p><h1 id="将来的想法"><a href="#将来的想法" class="headerlink" title="将来的想法"></a>将来的想法</h1><p>网安组是两个方向，web和pwn，说实在的我现在两个都挺感兴趣，所以还在思考，至于其它的高数英语之类的学习太尼玛蛋疼了，就尼玛离谱，还有历史什么的，很让人头大，总之，先学着就完事了。</p><p style="color:red">感谢你来到了这个小地方.</p>![程序员嘛，也还行](D:\shit\source\_posts\Hello-everyone\kPlYAP.jpg)]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于这个博客&quot;&gt;&lt;a href=&quot;#关于这个博客&quot; class=&quot;headerlink&quot; title=&quot;关于这个博客&quot;&gt;&lt;/a&gt;关于这个博客&lt;/h1&gt;&lt;p&gt;首先，要感谢&lt;a href=&quot;https://lemonprefect.cn/&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
      <category term="成长记录" scheme="http://livefordead.github.io/tags/%E6%88%90%E9%95%BF%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
